From 20488a0321374c2bebe239b011f5fed96bc89a40 Mon Sep 17 00:00:00 2001
From: "Luke D. Jones" <luke@ljones.dev>
Date: Fri, 1 Dec 2023 16:57:19 +1300
Subject: [PATCH v7 4/4] HID: asus: add ROG Ally xpad settings

- move ROG specific stuff to new .c
- add a header for common parts
- add xpad mode
- add deadzones

Signed-off-by: Luke D. Jones <luke@ljones.dev>
---
 drivers/hid/Makefile                        |   2 +
 drivers/hid/{hid-asus.c => hid-asus-core.c} |  71 ++--
 drivers/hid/hid-asus-rog.c                  | 399 ++++++++++++++++++++
 drivers/hid/hid-asus.h                      |  51 +++
 4 files changed, 482 insertions(+), 41 deletions(-)
 rename drivers/hid/{hid-asus.c => hid-asus-core.c} (96%)
 create mode 100644 drivers/hid/hid-asus-rog.c
 create mode 100644 drivers/hid/hid-asus.h

diff --git a/drivers/hid/Makefile b/drivers/hid/Makefile
index 8a06d0f840bc..7c2436ed05d6 100644
--- a/drivers/hid/Makefile
+++ b/drivers/hid/Makefile
@@ -23,6 +23,8 @@ hid-logitech-$(CONFIG_LOGIWHEELS_FF)	+= hid-lg4ff.o
 hid-wiimote-y		:= hid-wiimote-core.o hid-wiimote-modules.o
 hid-wiimote-$(CONFIG_DEBUG_FS)	+= hid-wiimote-debug.o
 
+hid-asus-y		:= hid-asus-core.o hid-asus-rog.o
+
 obj-$(CONFIG_HID_A4TECH)	+= hid-a4tech.o
 obj-$(CONFIG_HID_ACCUTOUCH)	+= hid-accutouch.o
 obj-$(CONFIG_HID_ALPS)		+= hid-alps.o
diff --git a/drivers/hid/hid-asus.c b/drivers/hid/hid-asus-core.c
similarity index 96%
rename from drivers/hid/hid-asus.c
rename to drivers/hid/hid-asus-core.c
index 3a1a6024d299..026705c43ee1 100644
--- a/drivers/hid/hid-asus.c
+++ b/drivers/hid/hid-asus-core.c
@@ -20,9 +20,8 @@
  *  Copyright (c) 2016 Frederik Wenigwieser <frederik.wenigwieser@gmail.com>
  */
 
-/*
- */
-
+#include <asm-generic/errno-base.h>
+#include <asm-generic/errno.h>
 #include <linux/dmi.h>
 #include <linux/hid.h>
 #include <linux/module.h>
@@ -32,6 +31,7 @@
 #include <linux/power_supply.h>
 #include <linux/leds.h>
 
+#include "hid-asus.h"
 #include "hid-ids.h"
 
 MODULE_AUTHOR("Yusuke Fujimaki <usk.fujimaki@gmail.com>");
@@ -47,10 +47,6 @@ MODULE_DESCRIPTION("Asus HID Keyboard and TouchPad");
 #define T100CHI_MOUSE_REPORT_ID 0x06
 #define FEATURE_REPORT_ID 0x0d
 #define INPUT_REPORT_ID 0x5d
-#define FEATURE_KBD_REPORT_ID 0x5a
-#define FEATURE_KBD_REPORT_SIZE 16
-#define FEATURE_KBD_LED_REPORT_ID1 0x5d
-#define FEATURE_KBD_LED_REPORT_ID2 0x5e
 
 #define SUPPORT_KBD_BACKLIGHT BIT(0)
 
@@ -71,20 +67,6 @@ MODULE_DESCRIPTION("Asus HID Keyboard and TouchPad");
 #define	BATTERY_STAT_CHARGING	(1)
 #define	BATTERY_STAT_FULL	(2)
 
-#define QUIRK_FIX_NOTEBOOK_REPORT	BIT(0)
-#define QUIRK_NO_INIT_REPORTS		BIT(1)
-#define QUIRK_SKIP_INPUT_MAPPING	BIT(2)
-#define QUIRK_IS_MULTITOUCH		BIT(3)
-#define QUIRK_NO_CONSUMER_USAGES	BIT(4)
-#define QUIRK_USE_KBD_BACKLIGHT		BIT(5)
-#define QUIRK_T100_KEYBOARD		BIT(6)
-#define QUIRK_T100CHI			BIT(7)
-#define QUIRK_G752_KEYBOARD		BIT(8)
-#define QUIRK_T90CHI			BIT(9)
-#define QUIRK_MEDION_E1239T		BIT(10)
-#define QUIRK_ROG_NKEY_KEYBOARD		BIT(11)
-#define QUIRK_ROG_CLAYMORE_II_KEYBOARD BIT(12)
-
 #define I2C_KEYBOARD_QUIRKS			(QUIRK_FIX_NOTEBOOK_REPORT | \
 						 QUIRK_NO_INIT_REPORTS | \
 						 QUIRK_NO_CONSUMER_USAGES)
@@ -113,22 +95,6 @@ struct asus_touchpad_info {
 	int report_size;
 };
 
-struct asus_drvdata {
-	unsigned long quirks;
-	struct hid_device *hdev;
-	struct input_dev *input;
-	struct input_dev *tp_kbd_input;
-	struct asus_kbd_leds *kbd_backlight;
-	const struct asus_touchpad_info *tp;
-	bool enable_backlight;
-	struct power_supply *battery;
-	struct power_supply_desc battery_desc;
-	int battery_capacity;
-	int battery_stat;
-	bool battery_in_query;
-	unsigned long battery_next_query;
-};
-
 static int asus_report_battery(struct asus_drvdata *, u8 *, int);
 
 static const struct asus_touchpad_info asus_i2c_tp = {
@@ -329,6 +295,16 @@ static int asus_raw_event(struct hid_device *hdev,
 	if (drvdata->battery && data[0] == BATTERY_REPORT_ID)
 		return asus_report_battery(drvdata, data, size);
 
+	// TODO: remove after debugging
+	// if (data[0] == 0x5a || data[0] == 0x5d || data[0] == 0x5e){
+	// 	 for (int i = 0; i < size; i++) {
+	// 		if (i == 0)
+	// 			printk(KERN_INFO "GOT: %02x,", data[i]);
+	// 		else
+	// 			printk(KERN_CONT "%02x,", data[i]);
+	// 	 }
+	// }
+
 	if (drvdata->tp && data[0] == INPUT_REPORT_ID)
 		return asus_report_input(drvdata, data, size);
 
@@ -365,7 +341,7 @@ static int asus_raw_event(struct hid_device *hdev,
 	return 0;
 }
 
-static int asus_kbd_set_report(struct hid_device *hdev, const u8 *buf, size_t buf_size)
+int asus_kbd_set_report(struct hid_device *hdev, const u8 *buf, size_t buf_size)
 {
 	unsigned char *dmabuf;
 	int ret;
@@ -386,6 +362,13 @@ static int asus_kbd_set_report(struct hid_device *hdev, const u8 *buf, size_t bu
 	return ret;
 }
 
+int asus_kbd_get_report(struct hid_device *hdev, u8 *out_buf, size_t out_buf_size)
+{
+	return hid_hw_raw_request(hdev, FEATURE_KBD_REPORT_ID, out_buf,
+				 out_buf_size, HID_FEATURE_REPORT,
+				 HID_REQ_GET_REPORT);
+}
+
 static int asus_kbd_init(struct hid_device *hdev, u8 report_id)
 {
 	const u8 buf[] = { report_id, 0x41, 0x53, 0x55, 0x53, 0x20, 0x54,
@@ -846,8 +829,8 @@ static int asus_input_mapping(struct hid_device *hdev,
 		case 0xb2: asus_map_key_clear(KEY_PROG2);	break; /* Fn+Left previous aura */
 		case 0xb3: asus_map_key_clear(KEY_PROG3);	break; /* Fn+Left next aura */
 		case 0x6a: asus_map_key_clear(KEY_F13);		break; /* Screenpad toggle */
-		case 0x4b: asus_map_key_clear(KEY_F14);		break; /* Arrows/Pg-Up/Dn toggle */
-		case 0xa5: asus_map_key_clear(KEY_F15);		break; /* ROG Ally left back */
+		case 0x4b: asus_map_key_clear(KEY_F14);		break; /* Arrows/Pg-Up/Dn toggle, Ally M1 */
+		case 0xa5: asus_map_key_clear(KEY_F15);		break; /* ROG Ally M2 */
 		case 0xa6: asus_map_key_clear(KEY_F16);		break; /* ROG Ally QAM button */
 		case 0xa7: asus_map_key_clear(KEY_F17);		break; /* ROG Ally ROG long-press */
 		case 0xa8: asus_map_key_clear(KEY_F18);		break; /* ROG Ally ROG long-press-release */
@@ -1063,6 +1046,10 @@ static int asus_probe(struct hid_device *hdev, const struct hid_device_id *id)
 		}
 	}
 
+	/* all ROG devices have this HID interface but we will focus on Ally for now */
+	if (drvdata->quirks & QUIRK_ROG_NKEY_KEYBOARD && hid_is_usb(hdev))
+		rog_ally.probe(hdev, &rog_ally);
+
 	ret = hid_parse(hdev);
 	if (ret) {
 		hid_err(hdev, "Asus hid parse failed: %d\n", ret);
@@ -1112,6 +1099,8 @@ static void asus_remove(struct hid_device *hdev)
 		cancel_work_sync(&drvdata->kbd_backlight->work);
 	}
 
+	rog_ally.remove(hdev, &rog_ally);
+
 	hid_hw_stop(hdev);
 }
 
@@ -1245,7 +1234,7 @@ static const struct hid_device_id asus_devices[] = {
 	  QUIRK_USE_KBD_BACKLIGHT | QUIRK_ROG_NKEY_KEYBOARD },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_ASUSTEK,
 	    USB_DEVICE_ID_ASUSTEK_ROG_NKEY_ALLY),
-	  QUIRK_USE_KBD_BACKLIGHT | QUIRK_ROG_NKEY_KEYBOARD },
+	  QUIRK_USE_KBD_BACKLIGHT | QUIRK_ROG_NKEY_KEYBOARD | QUIRK_ROG_ALLY_XPAD },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_ASUSTEK,
 	    USB_DEVICE_ID_ASUSTEK_ROG_CLAYMORE_II_KEYBOARD),
 	  QUIRK_ROG_CLAYMORE_II_KEYBOARD },
diff --git a/drivers/hid/hid-asus-rog.c b/drivers/hid/hid-asus-rog.c
new file mode 100644
index 000000000000..e533a0161572
--- /dev/null
+++ b/drivers/hid/hid-asus-rog.c
@@ -0,0 +1,399 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ *  HID driver for Asus ROG laptops and Ally
+ *
+ *  Copyright (c) 2016 Yusuke Fujimaki <usk.fujimaki@gmail.com>
+ */
+
+#include <linux/hid.h>
+#include <linux/types.h>
+#include <linux/usb.h>
+
+#include "hid-asus.h"
+
+/* required so we can have nested attributes with same name but different functions */
+#define ALLY_DEVICE_ATTR_RW(_name, _sysfs_name) \
+	struct device_attribute dev_attr_##_name = __ATTR(_sysfs_name, 0644, _name##_show, _name##_store)
+
+#define ALLY_DEVICE_ATTR_RO(_name, _sysfs_name) \
+	struct device_attribute dev_attr_##_name = __ATTR(_sysfs_name, 0444, _name##_show, NULL)
+
+enum ally_xpad_mode {
+	ally_xpad_mode_game	= 0x01,
+	ally_xpad_mode_wasd	= 0x02,
+	ally_xpad_mode_mouse	= 0x03,
+};
+
+enum ally_xpad_cmd {
+	ally_xpad_cmd_set_mode		= 0x01,
+	ally_xpad_cmd_set_js_dz		= 0x04, /* deadzones */
+	ally_xpad_cmd_set_tr_dz		= 0x05, /* deadzones */
+	ally_xpad_cmd_check_ready	= 0x0A,
+};
+
+enum ally_xpad_axis {
+	ally_xpad_axis_xy_left	= 0x01,
+	ally_xpad_axis_xy_right	= 0x02,
+	ally_xpad_axis_z_left	= 0x03,
+	ally_xpad_axis_z_right	= 0x04,
+};
+
+/* ROG Ally has many settings related to the gamepad, all using the same n-key endpoint */
+struct asus_rog_ally {
+	enum ally_xpad_mode mode;
+	/*
+	 * index: [joysticks/triggers][left(2 bytes), right(2 bytes)]
+	 * joysticks: 2 bytes: inner, outer
+	 * triggers: 2 bytes: lower, upper
+	 * min/max: 0-64
+	 */
+	u8 deadzones[2][4];
+	/*
+	 * index: left, right
+	 * max: 64
+	 */
+	u8 vibration_intensity[2];
+	/*
+	 * index: [joysticks][2 byte stepping per point]
+	 * - 4 points of 2 bytes each
+	 * - byte 0 of pair = stick move %
+	 * - byte 1 of pair = stick response %
+	 * - min/max: 1-63
+	 */
+	bool supports_response_curves;
+	u8 response_curve [2][8];
+	/*
+	 * left = byte 0, right = byte 1
+	 */
+	bool supports_anti_deadzones;
+	u8 anti_deadzones[2];
+};
+
+/* ASUS ROG Ally device specific attributes */
+
+static struct asus_rog_ally* __rog_ally_data(struct device *raw_dev) {
+	struct hid_device *hdev = to_hid_device(raw_dev);
+	return ((struct asus_drvdata*)hid_get_drvdata(hdev))->rog_ally_data;
+}
+
+/* This should be called before any attempts to set device functions */
+static int __gamepad_check_ready(struct hid_device *hdev)
+{
+	u8 *hidbuf;
+	int ret;
+
+	hidbuf = kzalloc(FEATURE_ROG_ALLY_REPORT_SIZE, GFP_KERNEL);
+	if (!hidbuf)
+		return -ENOMEM;
+
+	hidbuf[0] = FEATURE_KBD_REPORT_ID;
+	hidbuf[1] = 0xD1;
+	hidbuf[2] = ally_xpad_cmd_check_ready;
+	hidbuf[3] = 01;
+	ret = asus_kbd_set_report(hdev, hidbuf, FEATURE_ROG_ALLY_REPORT_SIZE);
+	if (ret < 0)
+		goto report_fail;
+
+	hidbuf[0] = hidbuf[1] = hidbuf[2] = hidbuf[3] = 0;
+	ret = asus_kbd_get_report(hdev, hidbuf, FEATURE_ROG_ALLY_REPORT_SIZE);
+	if (ret < 0)
+		goto report_fail;
+
+	ret = hidbuf[2] == ally_xpad_cmd_check_ready;
+	if (!ret) {
+		hid_warn(hdev, "ROG Ally not ready\n");
+		ret = -ENOMSG;
+	}
+	
+	kfree(hidbuf);
+	return ret;
+
+report_fail:
+	hid_dbg(hdev, "ROG Ally check failed get report: %d\n", ret);
+	kfree(hidbuf);
+	return ret;
+}
+
+// TODO: general purpose request function which checks the device is ready before setting
+/* The gamepad mode also needs to be set on boot/mod-load and shutdown */
+static ssize_t __gamepad_set_mode(struct device *raw_dev, int val) {
+	struct hid_device *hdev = to_hid_device(raw_dev);
+	u8 *hidbuf;
+	int ret;
+
+	ret = __gamepad_check_ready(hdev);
+	if (ret < 0)
+		return ret;
+
+	hidbuf = kzalloc(FEATURE_ROG_ALLY_REPORT_SIZE, GFP_KERNEL);
+	if (!hidbuf)
+		return -ENOMEM;
+
+	hidbuf[0] = FEATURE_KBD_REPORT_ID;
+	hidbuf[1] = 0xD1;
+	hidbuf[2] = ally_xpad_cmd_set_mode;
+	hidbuf[3] = 0x01;
+	hidbuf[4] = val;
+
+	ret = asus_kbd_set_report(hdev, hidbuf, FEATURE_ROG_ALLY_REPORT_SIZE);
+	if (ret < 0) {
+		kfree(hidbuf);
+		return ret;
+	}
+
+	// TODO: only set on boot. Or if a default for a mode is retained
+	hidbuf[2] = 0x02;
+	hidbuf[3] = 0x08;
+	hidbuf[4] = 0x2c;
+	hidbuf[5] = 0x02;
+	hidbuf[7] = 0x10; // M1
+	hidbuf[27] = 0x02;
+	hidbuf[29] = 0x18; // M2
+	asus_kbd_set_report(hdev, hidbuf, FEATURE_ROG_ALLY_REPORT_SIZE);
+
+	kfree(hidbuf);
+	return 0;
+}
+
+static ssize_t gamepad_mode_show(struct device *raw_dev, struct device_attribute *attr, char *buf) {
+	struct asus_rog_ally *rog_ally = __rog_ally_data(raw_dev);
+	return sysfs_emit(buf, "%d\n", rog_ally->mode);
+}
+
+static ssize_t gamepad_mode_store(struct device *raw_dev, struct device_attribute *attr, const char *buf, size_t count) {
+	struct asus_rog_ally *rog_ally = __rog_ally_data(raw_dev);
+	int ret, val;
+
+	ret = kstrtoint(buf, 0, &val);
+	if (ret)
+		return ret;
+
+	if (val < ally_xpad_mode_game || val > ally_xpad_mode_mouse)
+		return -EINVAL;
+
+	rog_ally->mode = val;
+
+	ret = __gamepad_set_mode(raw_dev, val);
+	if (ret < 0)
+		return ret;
+
+	return count;
+}
+
+DEVICE_ATTR_RW(gamepad_mode);
+
+/* ROG Ally deadzones */
+static ssize_t __gamepad_set_deadzones(struct device *raw_dev, enum ally_xpad_axis axis, const char *buf) {
+	struct asus_rog_ally *rog_ally = __rog_ally_data(raw_dev);
+	struct hid_device *hdev = to_hid_device(raw_dev);
+	int ret, cmd, side, is_js;
+	u32 inner, outer;
+	u8 *hidbuf;
+
+	if (sscanf(buf, "%d %d", &inner, &outer) != 2)
+		return -EINVAL;
+
+	if (inner > 64 || outer > 64 || inner > outer)
+		return -EINVAL;
+
+	is_js = !(axis <= ally_xpad_axis_xy_right);
+	side = axis == ally_xpad_axis_xy_right
+		|| axis == ally_xpad_axis_z_right ? 2 : 0;
+	cmd = is_js ? ally_xpad_cmd_set_js_dz : ally_xpad_cmd_set_tr_dz;
+
+	rog_ally->deadzones[is_js][side] = inner;
+	rog_ally->deadzones[is_js][side+1] = outer;
+
+	ret = __gamepad_check_ready(hdev);
+	if (ret < 0)
+		return ret;
+
+	hidbuf = kzalloc(FEATURE_ROG_ALLY_REPORT_SIZE, GFP_KERNEL);
+	if (!hidbuf)
+		return -ENOMEM;
+
+	hidbuf[0] = FEATURE_KBD_REPORT_ID;
+	hidbuf[1] = 0xD1;
+	hidbuf[2] = cmd;
+	hidbuf[3] = 0x04; // length
+	hidbuf[4] = rog_ally->deadzones[is_js][0];
+	hidbuf[5] = rog_ally->deadzones[is_js][1];
+	hidbuf[6] = rog_ally->deadzones[is_js][2];
+	hidbuf[7] = rog_ally->deadzones[is_js][3];
+
+	ret = asus_kbd_set_report(hdev, hidbuf, FEATURE_ROG_ALLY_REPORT_SIZE);
+	kfree(hidbuf);
+	return ret;
+}
+
+static ssize_t axis_xyz_index_show(struct device *raw_dev, struct device_attribute *attr, char *buf) {
+	return sysfs_emit(buf, "inner outer\n");
+}
+
+static ssize_t axis_xy_left_deadzone_show(struct device *raw_dev, struct device_attribute *attr, char *buf) {
+	struct asus_rog_ally *rog_ally = __rog_ally_data(raw_dev);
+	return sysfs_emit(buf, "%d %d\n", rog_ally->deadzones[0][0], rog_ally->deadzones[0][1]);
+}
+
+static ssize_t axis_xy_left_deadzone_store(struct device *raw_dev, struct device_attribute *attr, const char *buf, size_t count) {
+	int ret = __gamepad_set_deadzones(raw_dev, ally_xpad_axis_xy_left, buf);
+	if (ret < 0)
+		return ret;
+	return count;
+}
+
+static ssize_t axis_xy_right_deadzone_show(struct device *raw_dev, struct device_attribute *attr, char *buf) {
+	struct asus_rog_ally *rog_ally = __rog_ally_data(raw_dev);
+	return sysfs_emit(buf, "%d %d\n", rog_ally->deadzones[0][2], rog_ally->deadzones[0][3]);
+}
+
+static ssize_t axis_xy_right_deadzone_store(struct device *raw_dev, struct device_attribute *attr, const char *buf, size_t count) {
+	int ret = __gamepad_set_deadzones(raw_dev, ally_xpad_axis_xy_right, buf);
+	if (ret < 0)
+		return ret;
+	return count;
+}
+
+static ssize_t axis_z_left_deadzone_show(struct device *raw_dev, struct device_attribute *attr, char *buf) {
+	struct asus_rog_ally *rog_ally = __rog_ally_data(raw_dev);
+	return sysfs_emit(buf, "%d %d\n", rog_ally->deadzones[1][0], rog_ally->deadzones[1][1]);
+}
+
+static ssize_t axis_z_left_deadzone_store(struct device *raw_dev, struct device_attribute *attr, const char *buf, size_t count) {
+	int ret = __gamepad_set_deadzones(raw_dev, ally_xpad_axis_z_left, buf);
+	if (ret < 0)
+		return ret;
+	return count;
+}
+
+static ssize_t axis_z_right_deadzone_show(struct device *raw_dev, struct device_attribute *attr, char *buf) {
+	struct asus_rog_ally *rog_ally = __rog_ally_data(raw_dev);
+	return sysfs_emit(buf, "%d %d\n", rog_ally->deadzones[1][2], rog_ally->deadzones[1][3]);
+}
+
+static ssize_t axis_z_right_deadzone_store(struct device *raw_dev, struct device_attribute *attr, const char *buf, size_t count) {
+	int ret = __gamepad_set_deadzones(raw_dev, ally_xpad_axis_z_right, buf);
+	if (ret < 0)
+		return ret;
+	return count;
+}
+
+ALLY_DEVICE_ATTR_RO(axis_xyz_index, index);
+ALLY_DEVICE_ATTR_RW(axis_xy_left_deadzone, deadzone);
+ALLY_DEVICE_ATTR_RW(axis_xy_right_deadzone, deadzone);
+ALLY_DEVICE_ATTR_RW(axis_z_left_deadzone, deadzone);
+ALLY_DEVICE_ATTR_RW(axis_z_right_deadzone, deadzone);
+
+static struct attribute *gamepad_axis_xy_left_attrs[] = {
+	&dev_attr_axis_xy_left_deadzone.attr,
+	NULL
+};
+static const struct attribute_group ally_controller_axis_xy_left_attr_group = {
+	.name = "axis_xy_left",
+	.attrs = gamepad_axis_xy_left_attrs,
+};
+
+static struct attribute *gamepad_axis_xy_right_attrs[] = {
+	&dev_attr_axis_xy_right_deadzone.attr,
+	NULL
+};
+static const struct attribute_group ally_controller_axis_xy_right_attr_group = {
+	.name = "axis_xy_right",
+	.attrs = gamepad_axis_xy_right_attrs,
+};
+
+static struct attribute *gamepad_axis_z_left_attrs[] = {
+	&dev_attr_axis_z_left_deadzone.attr,
+	NULL
+};
+static const struct attribute_group ally_controller_axis_z_left_attr_group = {
+	.name = "axis_z_left",
+	.attrs = gamepad_axis_z_left_attrs,
+};
+
+static struct attribute *gamepad_axis_z_right_attrs[] = {
+	&dev_attr_axis_z_right_deadzone.attr,
+	NULL
+};
+static const struct attribute_group ally_controller_axis_z_right_attr_group = {
+	.name = "axis_z_right",
+	.attrs = gamepad_axis_z_right_attrs,
+};
+
+static struct attribute *gamepad_device_attrs[] = {
+	&dev_attr_gamepad_mode.attr,
+	NULL
+};
+
+static const struct attribute_group ally_controller_attr_group = {
+	.attrs = gamepad_device_attrs,
+};
+
+static const struct attribute_group *gamepad_device_attr_groups[] = {
+	&ally_controller_attr_group,
+	&ally_controller_axis_xy_left_attr_group,
+	&ally_controller_axis_xy_right_attr_group,
+	&ally_controller_axis_z_left_attr_group,
+	&ally_controller_axis_z_right_attr_group,
+	NULL
+};
+
+static int asus_rog_ally_probe(struct hid_device *hdev, const struct rog_ops *ops)
+{
+	struct asus_drvdata *drvdata = hid_get_drvdata(hdev);
+	int ret;
+
+	/* all ROG devices have this HID interface but we will focus on Ally for now */
+	if (drvdata->quirks & QUIRK_ROG_NKEY_KEYBOARD && hid_is_usb(hdev)) {
+		struct usb_interface *intf = to_usb_interface(hdev->dev.parent);
+
+		if (intf->altsetting->desc.bInterfaceNumber == 0) {
+			hid_info(hdev, "Setting up ROG USB interface\n");
+			/* initialise and set up USB, common to ROG */
+			// TODO:
+
+			/* initialise the Ally data */
+			if (drvdata->quirks & QUIRK_ROG_ALLY_XPAD) {
+				hid_info(hdev, "Setting up ROG Ally interface\n");
+				
+				drvdata->rog_ally_data = devm_kzalloc(&hdev->dev, sizeof(*drvdata->rog_ally_data), GFP_KERNEL);
+				if (!drvdata->rog_ally_data) {
+					hid_err(hdev, "Can't alloc Asus ROG USB interface\n");
+					ret = -ENOMEM;
+					goto err_stop_hw;
+				}
+				drvdata->rog_ally_data->mode = ally_xpad_mode_game;
+				drvdata->rog_ally_data->deadzones[0][1] = 64;
+				drvdata->rog_ally_data->deadzones[0][3] = 64;
+				drvdata->rog_ally_data->deadzones[1][1] = 64;
+				drvdata->rog_ally_data->deadzones[1][3] = 64;
+
+				ret = __gamepad_set_mode(&hdev->dev, ally_xpad_mode_game);
+				if (ret < 0)
+					return ret;
+			}
+
+			if (sysfs_create_groups(&hdev->dev.kobj, gamepad_device_attr_groups))
+				goto err_stop_hw;
+		}
+	}
+
+	return 0;
+err_stop_hw:
+	hid_hw_stop(hdev);
+	return ret;
+}
+
+void asus_rog_ally_remove(struct hid_device *hdev, const struct rog_ops *ops)
+{
+        struct asus_drvdata *drvdata = hid_get_drvdata(hdev);
+        if (drvdata->rog_ally_data) {
+		__gamepad_set_mode(&hdev->dev, ally_xpad_mode_mouse);
+		sysfs_remove_groups(&hdev->dev.kobj, gamepad_device_attr_groups);
+	}
+}
+
+const struct rog_ops rog_ally = {
+        .probe = asus_rog_ally_probe,
+        .remove = asus_rog_ally_remove,
+};
diff --git a/drivers/hid/hid-asus.h b/drivers/hid/hid-asus.h
new file mode 100644
index 000000000000..e7d7041b56fb
--- /dev/null
+++ b/drivers/hid/hid-asus.h
@@ -0,0 +1,51 @@
+#include <linux/hid.h>
+#include <linux/types.h>
+
+#define FEATURE_KBD_REPORT_ID		0x5a
+#define FEATURE_KBD_REPORT_SIZE		16
+#define FEATURE_KBD_LED_REPORT_ID1	0x5d
+#define FEATURE_KBD_LED_REPORT_ID2	0x5e
+#define FEATURE_ROG_ALLY_REPORT_SIZE	64
+
+#define QUIRK_FIX_NOTEBOOK_REPORT	BIT(0)
+#define QUIRK_NO_INIT_REPORTS		BIT(1)
+#define QUIRK_SKIP_INPUT_MAPPING	BIT(2)
+#define QUIRK_IS_MULTITOUCH		BIT(3)
+#define QUIRK_NO_CONSUMER_USAGES	BIT(4)
+#define QUIRK_USE_KBD_BACKLIGHT		BIT(5)
+#define QUIRK_T100_KEYBOARD		BIT(6)
+#define QUIRK_T100CHI			BIT(7)
+#define QUIRK_G752_KEYBOARD		BIT(8)
+#define QUIRK_T90CHI			BIT(9)
+#define QUIRK_MEDION_E1239T		BIT(10)
+#define QUIRK_ROG_NKEY_KEYBOARD		BIT(11)
+#define QUIRK_ROG_CLAYMORE_II_KEYBOARD	BIT(12)
+#define QUIRK_ROG_ALLY_XPAD		BIT(13)
+
+struct asus_drvdata {
+	unsigned long quirks;
+	struct hid_device *hdev;
+	struct input_dev *input;
+	struct input_dev *tp_kbd_input;
+	struct asus_kbd_leds *kbd_backlight;
+	const struct asus_touchpad_info *tp;
+	bool enable_backlight;
+	struct power_supply *battery;
+	struct power_supply_desc battery_desc;
+	int battery_capacity;
+	int battery_stat;
+	bool battery_in_query;
+	unsigned long battery_next_query;
+	struct asus_rog_ally *rog_ally_data;
+};
+
+extern int asus_kbd_set_report(struct hid_device *hdev, const u8 *buf, size_t buf_size);
+
+extern int asus_kbd_get_report(struct hid_device *hdev, u8 *out_buf, size_t out_buf_size);
+
+struct rog_ops {
+	int (*probe) (struct hid_device *hdev, const struct rog_ops *ops);
+	void (*remove) (struct hid_device *hdev, const struct rog_ops *ops);
+};
+
+extern const struct rog_ops rog_ally;
\ No newline at end of file
-- 
2.41.0

