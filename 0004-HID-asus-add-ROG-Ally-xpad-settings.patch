From 89b9e9a58ddfe3c6d400d08c607b50b3e2c60cbf Mon Sep 17 00:00:00 2001
From: "Luke D. Jones" <luke@ljones.dev>
Date: Fri, 1 Dec 2023 16:57:19 +1300
Subject: [PATCH v10 4/4] HID: asus: add ROG Ally xpad settings

- move ROG specific stuff to new .c
- add a header for common parts
- add xpad mode
- add deadzones
- add gamepad button remapping
- add gamepad mapping reset for xpad and wasd modes

Signed-off-by: Luke D. Jones <luke@ljones.dev>
---
 drivers/hid/Makefile                        |    2 +
 drivers/hid/{hid-asus.c => hid-asus-core.c} |   71 +-
 drivers/hid/hid-asus-rog.c                  | 1206 +++++++++++++++++++
 drivers/hid/hid-asus.h                      |   51 +
 4 files changed, 1289 insertions(+), 41 deletions(-)
 rename drivers/hid/{hid-asus.c => hid-asus-core.c} (96%)
 create mode 100644 drivers/hid/hid-asus-rog.c
 create mode 100644 drivers/hid/hid-asus.h

diff --git a/drivers/hid/Makefile b/drivers/hid/Makefile
index 8a06d0f840bc..7c2436ed05d6 100644
--- a/drivers/hid/Makefile
+++ b/drivers/hid/Makefile
@@ -23,6 +23,8 @@ hid-logitech-$(CONFIG_LOGIWHEELS_FF)	+= hid-lg4ff.o
 hid-wiimote-y		:= hid-wiimote-core.o hid-wiimote-modules.o
 hid-wiimote-$(CONFIG_DEBUG_FS)	+= hid-wiimote-debug.o
 
+hid-asus-y		:= hid-asus-core.o hid-asus-rog.o
+
 obj-$(CONFIG_HID_A4TECH)	+= hid-a4tech.o
 obj-$(CONFIG_HID_ACCUTOUCH)	+= hid-accutouch.o
 obj-$(CONFIG_HID_ALPS)		+= hid-alps.o
diff --git a/drivers/hid/hid-asus.c b/drivers/hid/hid-asus-core.c
similarity index 96%
rename from drivers/hid/hid-asus.c
rename to drivers/hid/hid-asus-core.c
index 3a1a6024d299..026705c43ee1 100644
--- a/drivers/hid/hid-asus.c
+++ b/drivers/hid/hid-asus-core.c
@@ -20,9 +20,8 @@
  *  Copyright (c) 2016 Frederik Wenigwieser <frederik.wenigwieser@gmail.com>
  */
 
-/*
- */
-
+#include <asm-generic/errno-base.h>
+#include <asm-generic/errno.h>
 #include <linux/dmi.h>
 #include <linux/hid.h>
 #include <linux/module.h>
@@ -32,6 +31,7 @@
 #include <linux/power_supply.h>
 #include <linux/leds.h>
 
+#include "hid-asus.h"
 #include "hid-ids.h"
 
 MODULE_AUTHOR("Yusuke Fujimaki <usk.fujimaki@gmail.com>");
@@ -47,10 +47,6 @@ MODULE_DESCRIPTION("Asus HID Keyboard and TouchPad");
 #define T100CHI_MOUSE_REPORT_ID 0x06
 #define FEATURE_REPORT_ID 0x0d
 #define INPUT_REPORT_ID 0x5d
-#define FEATURE_KBD_REPORT_ID 0x5a
-#define FEATURE_KBD_REPORT_SIZE 16
-#define FEATURE_KBD_LED_REPORT_ID1 0x5d
-#define FEATURE_KBD_LED_REPORT_ID2 0x5e
 
 #define SUPPORT_KBD_BACKLIGHT BIT(0)
 
@@ -71,20 +67,6 @@ MODULE_DESCRIPTION("Asus HID Keyboard and TouchPad");
 #define	BATTERY_STAT_CHARGING	(1)
 #define	BATTERY_STAT_FULL	(2)
 
-#define QUIRK_FIX_NOTEBOOK_REPORT	BIT(0)
-#define QUIRK_NO_INIT_REPORTS		BIT(1)
-#define QUIRK_SKIP_INPUT_MAPPING	BIT(2)
-#define QUIRK_IS_MULTITOUCH		BIT(3)
-#define QUIRK_NO_CONSUMER_USAGES	BIT(4)
-#define QUIRK_USE_KBD_BACKLIGHT		BIT(5)
-#define QUIRK_T100_KEYBOARD		BIT(6)
-#define QUIRK_T100CHI			BIT(7)
-#define QUIRK_G752_KEYBOARD		BIT(8)
-#define QUIRK_T90CHI			BIT(9)
-#define QUIRK_MEDION_E1239T		BIT(10)
-#define QUIRK_ROG_NKEY_KEYBOARD		BIT(11)
-#define QUIRK_ROG_CLAYMORE_II_KEYBOARD BIT(12)
-
 #define I2C_KEYBOARD_QUIRKS			(QUIRK_FIX_NOTEBOOK_REPORT | \
 						 QUIRK_NO_INIT_REPORTS | \
 						 QUIRK_NO_CONSUMER_USAGES)
@@ -113,22 +95,6 @@ struct asus_touchpad_info {
 	int report_size;
 };
 
-struct asus_drvdata {
-	unsigned long quirks;
-	struct hid_device *hdev;
-	struct input_dev *input;
-	struct input_dev *tp_kbd_input;
-	struct asus_kbd_leds *kbd_backlight;
-	const struct asus_touchpad_info *tp;
-	bool enable_backlight;
-	struct power_supply *battery;
-	struct power_supply_desc battery_desc;
-	int battery_capacity;
-	int battery_stat;
-	bool battery_in_query;
-	unsigned long battery_next_query;
-};
-
 static int asus_report_battery(struct asus_drvdata *, u8 *, int);
 
 static const struct asus_touchpad_info asus_i2c_tp = {
@@ -329,6 +295,16 @@ static int asus_raw_event(struct hid_device *hdev,
 	if (drvdata->battery && data[0] == BATTERY_REPORT_ID)
 		return asus_report_battery(drvdata, data, size);
 
+	// TODO: remove after debugging
+	// if (data[0] == 0x5a || data[0] == 0x5d || data[0] == 0x5e){
+	// 	 for (int i = 0; i < size; i++) {
+	// 		if (i == 0)
+	// 			printk(KERN_INFO "GOT: %02x,", data[i]);
+	// 		else
+	// 			printk(KERN_CONT "%02x,", data[i]);
+	// 	 }
+	// }
+
 	if (drvdata->tp && data[0] == INPUT_REPORT_ID)
 		return asus_report_input(drvdata, data, size);
 
@@ -365,7 +341,7 @@ static int asus_raw_event(struct hid_device *hdev,
 	return 0;
 }
 
-static int asus_kbd_set_report(struct hid_device *hdev, const u8 *buf, size_t buf_size)
+int asus_kbd_set_report(struct hid_device *hdev, const u8 *buf, size_t buf_size)
 {
 	unsigned char *dmabuf;
 	int ret;
@@ -386,6 +362,13 @@ static int asus_kbd_set_report(struct hid_device *hdev, const u8 *buf, size_t bu
 	return ret;
 }
 
+int asus_kbd_get_report(struct hid_device *hdev, u8 *out_buf, size_t out_buf_size)
+{
+	return hid_hw_raw_request(hdev, FEATURE_KBD_REPORT_ID, out_buf,
+				 out_buf_size, HID_FEATURE_REPORT,
+				 HID_REQ_GET_REPORT);
+}
+
 static int asus_kbd_init(struct hid_device *hdev, u8 report_id)
 {
 	const u8 buf[] = { report_id, 0x41, 0x53, 0x55, 0x53, 0x20, 0x54,
@@ -846,8 +829,8 @@ static int asus_input_mapping(struct hid_device *hdev,
 		case 0xb2: asus_map_key_clear(KEY_PROG2);	break; /* Fn+Left previous aura */
 		case 0xb3: asus_map_key_clear(KEY_PROG3);	break; /* Fn+Left next aura */
 		case 0x6a: asus_map_key_clear(KEY_F13);		break; /* Screenpad toggle */
-		case 0x4b: asus_map_key_clear(KEY_F14);		break; /* Arrows/Pg-Up/Dn toggle */
-		case 0xa5: asus_map_key_clear(KEY_F15);		break; /* ROG Ally left back */
+		case 0x4b: asus_map_key_clear(KEY_F14);		break; /* Arrows/Pg-Up/Dn toggle, Ally M1 */
+		case 0xa5: asus_map_key_clear(KEY_F15);		break; /* ROG Ally M2 */
 		case 0xa6: asus_map_key_clear(KEY_F16);		break; /* ROG Ally QAM button */
 		case 0xa7: asus_map_key_clear(KEY_F17);		break; /* ROG Ally ROG long-press */
 		case 0xa8: asus_map_key_clear(KEY_F18);		break; /* ROG Ally ROG long-press-release */
@@ -1063,6 +1046,10 @@ static int asus_probe(struct hid_device *hdev, const struct hid_device_id *id)
 		}
 	}
 
+	/* all ROG devices have this HID interface but we will focus on Ally for now */
+	if (drvdata->quirks & QUIRK_ROG_NKEY_KEYBOARD && hid_is_usb(hdev))
+		rog_ally.probe(hdev, &rog_ally);
+
 	ret = hid_parse(hdev);
 	if (ret) {
 		hid_err(hdev, "Asus hid parse failed: %d\n", ret);
@@ -1112,6 +1099,8 @@ static void asus_remove(struct hid_device *hdev)
 		cancel_work_sync(&drvdata->kbd_backlight->work);
 	}
 
+	rog_ally.remove(hdev, &rog_ally);
+
 	hid_hw_stop(hdev);
 }
 
@@ -1245,7 +1234,7 @@ static const struct hid_device_id asus_devices[] = {
 	  QUIRK_USE_KBD_BACKLIGHT | QUIRK_ROG_NKEY_KEYBOARD },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_ASUSTEK,
 	    USB_DEVICE_ID_ASUSTEK_ROG_NKEY_ALLY),
-	  QUIRK_USE_KBD_BACKLIGHT | QUIRK_ROG_NKEY_KEYBOARD },
+	  QUIRK_USE_KBD_BACKLIGHT | QUIRK_ROG_NKEY_KEYBOARD | QUIRK_ROG_ALLY_XPAD },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_ASUSTEK,
 	    USB_DEVICE_ID_ASUSTEK_ROG_CLAYMORE_II_KEYBOARD),
 	  QUIRK_ROG_CLAYMORE_II_KEYBOARD },
diff --git a/drivers/hid/hid-asus-rog.c b/drivers/hid/hid-asus-rog.c
new file mode 100644
index 000000000000..897c13769bae
--- /dev/null
+++ b/drivers/hid/hid-asus-rog.c
@@ -0,0 +1,1206 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ *  HID driver for Asus ROG laptops and Ally
+ *
+ *  Copyright (c) 2016 Yusuke Fujimaki <usk.fujimaki@gmail.com>
+ */
+
+#include <linux/hid.h>
+#include <linux/types.h>
+#include <linux/usb.h>
+
+#include "hid-asus.h"
+
+/* required so we can have nested attributes with same name but different functions */
+#define ALLY_DEVICE_ATTR_RW(_name, _sysfs_name)    \
+	struct device_attribute dev_attr_##_name = \
+		__ATTR(_sysfs_name, 0644, _name##_show, _name##_store)
+
+#define ALLY_DEVICE_ATTR_RO(_name, _sysfs_name) \
+	struct device_attribute dev_attr_##_name = __ATTR(_sysfs_name, 0444, _name##_show, NULL)
+
+#define ALLY_DEVICE_ATTR_WO(_name, _sysfs_name) \
+	struct device_attribute dev_attr_##_name = __ATTR(_sysfs_name, 0200, NULL, _name##_store)
+
+#define BTN_CODE_LEN 11
+#define MAPPING_BLOCK_LEN 44
+
+enum ally_xpad_mode {
+	ally_xpad_mode_game = 0x01,
+	ally_xpad_mode_wasd = 0x02,
+	ally_xpad_mode_mouse = 0x03,
+};
+
+enum ally_xpad_cmd {
+	ally_xpad_cmd_set_mode = 0x01,
+	ally_xpad_cmd_set_js_dz = 0x04, /* deadzones */
+	ally_xpad_cmd_set_tr_dz = 0x05, /* deadzones */
+	ally_xpad_cmd_check_ready = 0x0A,
+};
+
+enum ally_xpad_axis {
+	ally_xpad_axis_xy_left = 0x01,
+	ally_xpad_axis_xy_right = 0x02,
+	ally_xpad_axis_z_left = 0x03,
+	ally_xpad_axis_z_right = 0x04,
+};
+
+enum ally_out_dev {
+	ally_out_dev_blank = 0x00,
+	ally_out_dev_xpad = 0x01,
+	ally_out_dev_keyboard = 0x02,
+	ally_out_dev_mouse = 0x03,
+	ally_out_dev_macro = 0x04,
+	ally_out_dev_media = 0x05,
+};
+
+enum btn_pair {
+	btn_pair_dpad_u_d = 0x01,
+	btn_pair_dpad_l_r = 0x02,
+	btn_pair_ls_rs = 0x03,
+	btn_pair_lb_rb = 0x04,
+	btn_pair_a_b = 0x05,
+	btn_pair_x_y = 0x06,
+	btn_pair_view_menu = 0x07,
+	btn_pair_m1_m2 = 0x08,
+	btn_pair_lt_rt = 0x09,
+};
+
+enum btn_pair_side {
+	btn_pair_side_left = 0x00,
+	btn_pair_side_right = 0x01,
+};
+
+/* ROG Ally has many settings related to the gamepad, all using the same n-key endpoint */
+struct asus_rog_ally {
+	enum ally_xpad_mode mode;
+	/*ally_xpad_mode
+	 * index: [joysticks/triggers][left(2 bytes), right(2 bytes)]
+	 * joysticks: 2 bytes: inner, outer
+	 * triggers: 2 bytes: lower, upper
+	 * min/max: 0-64
+	 */
+	u8 deadzones[2][4];
+	/*
+	 * index: left, right
+	 * max: 64
+	 */
+	u8 vibration_intensity[2];
+	/*
+	 * index: [joysticks][2 byte stepping per point]
+	 * - 4 points of 2 bytes each
+	 * - byte 0 of pair = stick move %
+	 * - byte 1 of pair = stick response %
+	 * - min/max: 1-63
+	 */
+	bool supports_response_curves;
+	u8 response_curve[2][8];
+	/*
+	 * left = byte 0, right = byte 1
+	 */
+	bool supports_anti_deadzones;
+	u8 anti_deadzones[2];
+
+	/*
+	 * index: [mode][phys pair][b1, b1 secondary, b2, b2 secondary, blocks of 11]
+	*/
+	u8 key_mapping[ally_xpad_mode_mouse][btn_pair_lt_rt][MAPPING_BLOCK_LEN];
+};
+
+#define PAD_A "pad_a"
+#define PAD_B "pad_b"
+#define PAD_X "pad_x"
+#define PAD_Y "pad_y"
+#define PAD_LB "pad_lb"
+#define PAD_RB "pad_rb"
+#define PAD_LS "pad_ls"
+#define PAD_RS "pad_rs"
+#define PAD_DPAD_UP "pad_dpad_up"
+#define PAD_DPAD_DOWN "pad_dpad_down"
+#define PAD_DPAD_LEFT "pad_dpad_left"
+#define PAD_DPAD_RIGHT "pad_dpad_right"
+#define PAD_VIEW "pad_view"
+#define PAD_MENU "pad_menu"
+#define PAD_XBOX "pad_xbox"
+
+#define KB_M1 "kb_m1"
+#define KB_M2 "kb_m2"
+#define KB_ESC "kb_esc"
+#define KB_F1 "kb_f1"
+#define KB_F2 "kb_f2"
+#define KB_F3 "kb_f3"
+#define KB_F4 "kb_f4"
+#define KB_F5 "kb_f5"
+#define KB_F6 "kb_f6"
+#define KB_F7 "kb_f7"
+#define KB_F8 "kb_f8"
+#define KB_F9 "kb_f9"
+#define KB_F10 "kb_f10"
+#define KB_F11 "kb_f11"
+#define KB_F12 "kb_f12"
+#define KB_F14 "kb_f14"
+#define KB_F15 "kb_f15"
+
+#define KB_BACKTICK "kb_`"
+#define KB_1 "kb_1"
+#define KB_2 "kb_2"
+#define KB_3 "kb_3"
+#define KB_4 "kb_4"
+#define KB_5 "kb_5"
+#define KB_6 "kb_6"
+#define KB_7 "kb_7"
+#define KB_8 "kb_8"
+#define KB_9 "kb_9"
+#define KB_0 "kb_0"
+#define KB_HYPHEN "kb_-"
+#define KB_EQUALS "kb_="
+#define KB_BACKSPACE "kb_backspace"
+
+#define KB_TAB "kb_tab"
+#define KB_Q "kb_q"
+#define KB_W "kb_w"
+#define KB_E "kb_e"
+#define KB_R "kb_r"
+#define KB_T "kb_t"
+#define KB_Y "kb_y"
+#define KB_U "kb_u"
+//#defi KB_I neuf, "i")) out[2] = 0x1c;
+#define KB_O "kb_o"
+#define KB_P "kb_p"
+#define KB_LBRACKET "kb_["
+#define KB_RBRACKET "kb_]"
+#define KB_BACKSLASH "kb_bkslash"
+
+#define KB_CAPS "kb_caps"
+#define KB_A "kb_a"
+#define KB_S "kb_s"
+#define KB_D "kb_d"
+#define KB_F "kb_f"
+#define KB_G "kb_g"
+#define KB_H "kb_h"
+#define KB_J "kb_j"
+#define KB_K "kb_k"
+#define KB_L "kb_l"
+#define KB_SEMI "kb_;"
+#define KB_QUOTE "kb_'"
+#define KB_RET "kb_enter"
+
+#define KB_LSHIFT "kb_lshift"
+#define KB_Z "kb_z"
+#define KB_X "kb_x"
+#define KB_C "kb_c"
+#define KB_V "kb_v"
+#define KB_B "kb_b"
+#define KB_N "kb_n"
+#define KB_M "kb_m"
+#define KB_COMA "kb_,"
+#define KB_PERIOD "kb_."
+// #defKB_uf, "/")) out[2] = 0x52; missing
+#define KB_RSHIFT "kb_rshift"
+
+#define KB_LCTL "kb_lctl"
+#define KB_META "kb_meta"
+#define KB_LALT "kb_lalt"
+#define KB_SPACE "kb_space"
+#define KB_RALT "kb_ralt"
+#define KB_MENU "kb_menu"
+#define KB_RCTL "kb_rctl"
+
+#define KB_PRNTSCN "kb_prntscn"
+#define KB_SCRLCK "kb_scrlck"
+#define KB_PAUSE "kb_pause"
+#define KB_INS "kb_ins"
+#define KB_HOME "kb_home"
+#define KB_PGUP "kb_pgup"
+#define KB_DEL "kb_del"
+#define KB_END "kb_end"
+#define KB_PGDWN "kb_pgdwn"
+
+#define KB_UP_ARROW "kb_up_arrow"
+#define KB_DOWN_ARROW "kb_down_arrow"
+#define KB_LEFT_ARROW "kb_left_arrow"
+#define KB_RIGHT_ARROW "kb_right_arrow"
+
+#define NUMPAD_LCK "numpad_lck"
+#define NUMPAD_FWDSLASH "numpad_/"
+#define NUMPAD_STAR "numpad_*"
+#define NUMPAD_HYPHEN "numpad_-"
+#define NUMPAD_0 "numpad_0"
+#define NUMPAD_1 "numpad_1"
+#define NUMPAD_2 "numpad_2"
+#define NUMPAD_3 "numpad_3"
+#define NUMPAD_4 "numpad_4"
+#define NUMPAD_5 "numpad_5"
+#define NUMPAD_6 "numpad_6"
+#define NUMPAD_7 "numpad_7"
+#define NUMPAD_8 "numpad_8"
+#define NUMPAD_9 "numpad_9"
+#define NUMPAD_PLUS "numpad_+"
+#define NUMPAD_ENTER "numpad_enter"
+#define NUMPAD_PERIOD "numpad_."
+
+#define RAT_LCLICK "rat_lclick"
+#define RAT_RCLICK "rat_rclick"
+#define RAT_MCLICK "rat_mclick"
+#define RAT_WHEEL_UP "rat_wheel_up"
+#define RAT_WHEEL_DOWN "rat_wheel_down"
+
+#define MEDIA_SCREENSHOT "media_screenshot"
+#define MEDIA_SHOW_KEYBOARD "media_show_keyboard"
+#define MEDIA_SHOW_DESKTOP "media_show_desktop"
+#define MEDIA_START_RECORDING "media_start_recording"
+#define MEDIA_MIC_OFF "media_mic_off"
+#define MEDIA_VOL_DOWN "media_vol_down"
+#define MEDIA_VOL_UP "media_vol_up"
+
+static struct asus_rog_ally *__rog_ally_data(struct device *raw_dev)
+{
+	struct hid_device *hdev = to_hid_device(raw_dev);
+	return ((struct asus_drvdata *)hid_get_drvdata(hdev))->rog_ally_data;
+}
+
+/* writes the bytes for a requested key/function in to the out buffer */
+const static int __string_to_key_code(const char *buf, u8 *out, int out_len)
+{
+	u8 *save_buf;
+
+	if (out_len != BTN_CODE_LEN)
+		return -EINVAL;
+
+	save_buf = kzalloc(out_len, GFP_KERNEL);
+	if (!save_buf)
+		return -ENOMEM;
+	memcpy(save_buf, out, out_len);
+	memset(out, 0, out_len); // always clear before adjusting
+
+	// Allow clearing
+	if (!strcmp(buf, " ") || !strcmp(buf, "\n"))
+		goto success;
+
+	// set group xpad
+	out[0] = 0x01;
+	if (!strcmp(buf,      PAD_A)) out[1] = 0x01;
+	else if (!strcmp(buf, PAD_B)) out[1] = 0x02;
+	else if (!strcmp(buf, PAD_X)) out[1] = 0x03;
+	else if (!strcmp(buf, PAD_Y)) out[1] = 0x04;
+	else if (!strcmp(buf, PAD_LB)) out[1] = 0x05;
+	else if (!strcmp(buf, PAD_RB)) out[1] = 0x06;
+	else if (!strcmp(buf, PAD_LS)) out[1] = 0x07;
+	else if (!strcmp(buf, PAD_RS)) out[1] = 0x08;
+	else if (!strcmp(buf, PAD_DPAD_UP)) out[1] = 0x09;
+	else if (!strcmp(buf, PAD_DPAD_DOWN)) out[1] = 0x0a;
+	else if (!strcmp(buf, PAD_DPAD_LEFT)) out[1] = 0x0b;
+	else if (!strcmp(buf, PAD_DPAD_RIGHT)) out[1] = 0x0c;
+	else if (!strcmp(buf, PAD_VIEW)) out[1] = 0x11;
+	else if (!strcmp(buf, PAD_MENU)) out[1] = 0x12;
+	else if (!strcmp(buf, PAD_XBOX)) out[1] = 0x13;
+	if (out[1])
+		goto success;
+
+	// set group keyboard
+	out[0] = 0x02;
+	if (!strcmp(buf,      KB_M1)) out[2] = 0x8f;
+	else if (!strcmp(buf, KB_M2)) out[2] = 0x8e;
+	else if (!strcmp(buf, KB_ESC)) out[2] = 0x76;
+	else if (!strcmp(buf, KB_F1)) out[2] = 0x50;
+	else if (!strcmp(buf, KB_F2)) out[2] = 0x60;
+	else if (!strcmp(buf, KB_F3)) out[2] = 0x40;
+	else if (!strcmp(buf, KB_F4)) out[2] = 0x0c;
+	else if (!strcmp(buf, KB_F5)) out[2] = 0x03;
+	else if (!strcmp(buf, KB_F6)) out[2] = 0x0b;
+	else if (!strcmp(buf, KB_F7)) out[2] = 0x80;
+	else if (!strcmp(buf, KB_F8)) out[2] = 0x0a;
+	else if (!strcmp(buf, KB_F9)) out[2] = 0x01;
+	else if (!strcmp(buf, KB_F10)) out[2] = 0x09;
+	else if (!strcmp(buf, KB_F11)) out[2] = 0x78;
+	else if (!strcmp(buf, KB_F12)) out[2] = 0x07;
+	else if (!strcmp(buf, KB_F14)) out[2] = 0x10;
+	else if (!strcmp(buf, KB_F15)) out[2] = 0x18;
+
+	else if (!strcmp(buf, KB_BACKTICK)) out[2] = 0x0e;
+	else if (!strcmp(buf, KB_1)) out[2] = 0x16;
+	else if (!strcmp(buf, KB_2)) out[2] = 0x1e;
+	else if (!strcmp(buf, KB_3)) out[2] = 0x26;
+	else if (!strcmp(buf, KB_4)) out[2] = 0x25;
+	else if (!strcmp(buf, KB_5)) out[2] = 0x2e;
+	else if (!strcmp(buf, KB_6)) out[2] = 0x36;
+	else if (!strcmp(buf, KB_7)) out[2] = 0x3d;
+	else if (!strcmp(buf, KB_8)) out[2] = 0x3e;
+	else if (!strcmp(buf, KB_9)) out[2] = 0x46;
+	else if (!strcmp(buf, KB_0)) out[2] = 0x45;
+	else if (!strcmp(buf, KB_HYPHEN)) out[2] = 0x4e;
+	else if (!strcmp(buf, KB_EQUALS)) out[2] = 0x55;
+	else if (!strcmp(buf, KB_BACKSPACE)) out[2] = 0x66;
+
+	else if (!strcmp(buf, KB_TAB)) out[2] = 0x0d;
+	else if (!strcmp(buf, KB_Q)) out[2] = 0x15;
+	else if (!strcmp(buf, KB_W)) out[2] = 0x1d;
+	else if (!strcmp(buf, KB_E)) out[2] = 0x24;
+	else if (!strcmp(buf, KB_R)) out[2] = 0x2d;
+	else if (!strcmp(buf, KB_T)) out[2] = 0x2d;
+	else if (!strcmp(buf, KB_Y)) out[2] = 0x35;
+	else if (!strcmp(buf, KB_U)) out[2] = 0x3c;
+	// else if (!strcmp(buf, "i\n")) out[2] = 0x1c;
+	else if (!strcmp(buf, KB_O)) out[2] = 0x44;
+	else if (!strcmp(buf, KB_P)) out[2] = 0x4d;
+	else if (!strcmp(buf, KB_LBRACKET)) out[2] = 0x54;
+	else if (!strcmp(buf, KB_RBRACKET)) out[2] = 0x5b;
+	else if (!strcmp(buf, KB_BACKSLASH)) out[2] = 0x5d;
+
+	else if (!strcmp(buf, KB_CAPS)) out[2] = 0x58;
+	else if (!strcmp(buf, KB_A)) out[2] = 0x1c;
+	else if (!strcmp(buf, KB_S)) out[2] = 0x1b;
+	else if (!strcmp(buf, KB_D)) out[2] = 0x23;
+	else if (!strcmp(buf, KB_F)) out[2] = 0x2b;
+	else if (!strcmp(buf, KB_G)) out[2] = 0x34;
+	else if (!strcmp(buf, KB_H)) out[2] = 0x33;
+	else if (!strcmp(buf, KB_J)) out[2] = 0x3b;
+	else if (!strcmp(buf, KB_K)) out[2] = 0x42;
+	else if (!strcmp(buf, KB_L)) out[2] = 0x4b;
+	else if (!strcmp(buf, KB_SEMI)) out[2] = 0x4c;
+	else if (!strcmp(buf, KB_QUOTE)) out[2] = 0x52;
+	else if (!strcmp(buf, KB_RET)) out[2] = 0x5a;
+
+	else if (!strcmp(buf, KB_LSHIFT)) out[2] = 0x88;
+	else if (!strcmp(buf, KB_Z)) out[2] = 0x1a;
+	else if (!strcmp(buf, KB_X)) out[2] = 0x22;
+	else if (!strcmp(buf, KB_C)) out[2] = 0x21;
+	else if (!strcmp(buf, KB_V)) out[2] = 0x2a;
+	else if (!strcmp(buf, KB_B)) out[2] = 0x32;
+	else if (!strcmp(buf, KB_N)) out[2] = 0x31;
+	else if (!strcmp(buf, KB_M)) out[2] = 0x3a;
+	else if (!strcmp(buf, KB_COMA)) out[2] = 0x41;
+	else if (!strcmp(buf, KB_PERIOD)) out[2] = 0x49;
+	// else if (!strcmp(buf, "/\n")) out[2] = 0x52; missing
+	else if (!strcmp(buf, KB_RSHIFT)) out[2] = 0x89;
+
+	else if (!strcmp(buf, KB_LCTL)) out[2] = 0x8c;
+	else if (!strcmp(buf, KB_META)) out[2] = 0x82;
+	else if (!strcmp(buf, KB_LALT)) out[2] = 0xba;
+	else if (!strcmp(buf, KB_SPACE)) out[2] = 0x29;
+	else if (!strcmp(buf, KB_RALT)) out[2] = 0x8b;
+	else if (!strcmp(buf, KB_MENU)) out[2] = 0x84;
+	else if (!strcmp(buf, KB_RCTL)) out[2] = 0x8d;
+
+	else if (!strcmp(buf, KB_PRNTSCN)) out[2] = 0xc3;
+	else if (!strcmp(buf, KB_SCRLCK)) out[2] = 0x7e;
+	else if (!strcmp(buf, KB_PAUSE)) out[2] = 0x91;
+	else if (!strcmp(buf, KB_INS)) out[2] = 0xc2;
+	else if (!strcmp(buf, KB_HOME)) out[2] = 0x94;
+	else if (!strcmp(buf, KB_PGUP)) out[2] = 0x96;
+	else if (!strcmp(buf, KB_DEL)) out[2] = 0xc0;
+	else if (!strcmp(buf, KB_END)) out[2] = 0x95;
+	else if (!strcmp(buf, KB_PGDWN)) out[2] = 0x97;
+
+	else if (!strcmp(buf, KB_UP_ARROW)) out[2] = 0x99;
+	else if (!strcmp(buf, KB_DOWN_ARROW)) out[2] = 0x98;
+	else if (!strcmp(buf, KB_LEFT_ARROW)) out[2] = 0x91;
+	else if (!strcmp(buf, KB_RIGHT_ARROW)) out[2] = 0x9b;
+
+	else if (!strcmp(buf, NUMPAD_LCK)) out[2] = 0x77;
+	else if (!strcmp(buf, NUMPAD_FWDSLASH)) out[2] = 0x90;
+	else if (!strcmp(buf, NUMPAD_STAR)) out[2] = 0x7c;
+	else if (!strcmp(buf, NUMPAD_HYPHEN)) out[2] = 0x7b;
+	else if (!strcmp(buf, NUMPAD_0)) out[2] = 0x70;
+	else if (!strcmp(buf, NUMPAD_1)) out[2] = 0x69;
+	else if (!strcmp(buf, NUMPAD_2)) out[2] = 0x72;
+	else if (!strcmp(buf, NUMPAD_3)) out[2] = 0x7a;
+	else if (!strcmp(buf, NUMPAD_4)) out[2] = 0x6b;
+	else if (!strcmp(buf, NUMPAD_5)) out[2] = 0x73;
+	else if (!strcmp(buf, NUMPAD_6)) out[2] = 0x74;
+	else if (!strcmp(buf, NUMPAD_7)) out[2] = 0x6c;
+	else if (!strcmp(buf, NUMPAD_8)) out[2] = 0x75;
+	else if (!strcmp(buf, NUMPAD_9)) out[2] = 0x7d;
+	else if (!strcmp(buf, NUMPAD_PLUS)) out[2] = 0x79;
+	else if (!strcmp(buf, NUMPAD_ENTER)) out[2] = 0x81;
+	else if (!strcmp(buf, NUMPAD_PERIOD)) out[2] = 0x71;
+	if (out[2])
+		goto success;
+
+	out[0] = 0x03;
+	if (!strcmp(buf,      RAT_LCLICK)) out[4] = 0x01;
+	else if (!strcmp(buf, RAT_RCLICK)) out[4] = 0x02;
+	else if (!strcmp(buf, RAT_MCLICK)) out[4] = 0x03;
+	else if (!strcmp(buf, RAT_WHEEL_UP)) out[4] = 0x04;
+	else if (!strcmp(buf, RAT_WHEEL_DOWN)) out[4] = 0x05;
+	if (out[4] != 0)
+		goto success;
+
+	out[0] = 0x05;
+	if (!strcmp(buf,      MEDIA_SCREENSHOT)) out[3] = 0x16;
+	else if (!strcmp(buf, MEDIA_SHOW_KEYBOARD)) out[3] = 0x19;
+	else if (!strcmp(buf, MEDIA_SHOW_DESKTOP)) out[3] = 0x1c;
+	else if (!strcmp(buf, MEDIA_START_RECORDING)) out[3] = 0x1e;
+	else if (!strcmp(buf, MEDIA_MIC_OFF)) out[3] = 0x01;
+	else if (!strcmp(buf, MEDIA_VOL_DOWN)) out[3] = 0x02;
+	else if (!strcmp(buf, MEDIA_VOL_UP)) out[3] = 0x03;
+	if (out[3])
+		goto success;
+
+	// restore bytes if invalid input
+	memcpy(out, save_buf, out_len);
+	kfree(save_buf);
+	return -EINVAL;
+
+success:
+	kfree(save_buf);
+	return 0;
+}
+
+const static char* __btn_map_to_string(struct device *raw_dev, enum btn_pair pair, enum btn_pair_side side, bool secondary)
+{
+	struct asus_rog_ally *rog_ally = __rog_ally_data(raw_dev);
+	u8 *btn_block;
+	int offs;
+
+	// TODO: this little block is common
+	offs = side ? MAPPING_BLOCK_LEN / 2 : 0;
+	offs = secondary ? offs + BTN_CODE_LEN : offs;
+	btn_block = rog_ally->key_mapping[rog_ally->mode - 1][pair - 1] + offs;
+
+	if (btn_block[0] == 0x01) {
+		if (btn_block[1] == 0x01) return PAD_A;
+		if (btn_block[1] == 0x02) return PAD_B;
+		if (btn_block[1] == 0x03) return PAD_X;
+		if (btn_block[1] == 0x04) return PAD_Y;
+		if (btn_block[1] == 0x05) return PAD_LB;
+		if (btn_block[1] == 0x06) return PAD_RB;
+		if (btn_block[1] == 0x07) return PAD_LS;
+		if (btn_block[1] == 0x08) return PAD_RS;
+		if (btn_block[1] == 0x09) return PAD_DPAD_UP;
+		if (btn_block[1] == 0x0a) return PAD_DPAD_DOWN;
+		if (btn_block[1] == 0x0b) return PAD_DPAD_LEFT;
+		if (btn_block[1] == 0x0c) return PAD_DPAD_RIGHT;
+		if (btn_block[1] == 0x11) return PAD_VIEW;
+		if (btn_block[1] == 0x12) return PAD_MENU;
+		if (btn_block[1] == 0x13) return PAD_XBOX;
+	}
+
+	if (btn_block[0] == 0x02) {
+		if (btn_block[2] == 0x8f) return KB_M1;
+		if (btn_block[2] == 0x8e) return KB_M2;
+
+		if (btn_block[2] == 0x76) return KB_ESC;
+		if (btn_block[2] == 0x50) return KB_F1;
+		if (btn_block[2] == 0x60) return KB_F2;
+		if (btn_block[2] == 0x40) return KB_F3;
+		if (btn_block[2] == 0x0c) return KB_F4;
+		if (btn_block[2] == 0x03) return KB_F5;
+		if (btn_block[2] == 0x0b) return KB_F6;
+		if (btn_block[2] == 0x80) return KB_F7;
+		if (btn_block[2] == 0x0a) return KB_F8;
+		if (btn_block[2] == 0x01) return KB_F9;
+		if (btn_block[2] == 0x09) return KB_F10;
+		if (btn_block[2] == 0x78) return KB_F11;
+		if (btn_block[2] == 0x07) return KB_F12;
+		if (btn_block[2] == 0x10) return KB_F14;
+		if (btn_block[2] == 0x18) return KB_F15;
+
+		if (btn_block[2] == 0x0e) return KB_BACKTICK;
+		if (btn_block[2] == 0x16) return KB_1;
+		if (btn_block[2] == 0x1e) return KB_2;
+		if (btn_block[2] == 0x26) return KB_3;
+		if (btn_block[2] == 0x25) return KB_4;
+		if (btn_block[2] == 0x2e) return KB_5;
+		if (btn_block[2] == 0x36) return KB_6;
+		if (btn_block[2] == 0x3d) return KB_7;
+		if (btn_block[2] == 0x3e) return KB_8;
+		if (btn_block[2] == 0x46) return KB_9;
+		if (btn_block[2] == 0x45) return KB_0;
+		if (btn_block[2] == 0x4e) return KB_HYPHEN;
+		if (btn_block[2] == 0x55) return KB_EQUALS;
+		if (btn_block[2] == 0x66) return KB_BACKSPACE;
+
+		if (btn_block[2] == 0x0d) return KB_TAB;
+		if (btn_block[2] == 0x15) return KB_Q;
+		if (btn_block[2] == 0x1d) return KB_W;
+		if (btn_block[2] == 0x24) return KB_E;
+		if (btn_block[2] == 0x2d) return KB_R;
+		if (btn_block[2] == 0x2d) return KB_T;
+		if (btn_block[2] == 0x35) return KB_Y;
+		if (btn_block[2] == 0x3c) return KB_U;
+		// TODO: I
+		if (btn_block[2] == 0x44) return KB_O;
+		if (btn_block[2] == 0x4d) return KB_P;
+		if (btn_block[2] == 0x54) return KB_LBRACKET;
+		if (btn_block[2] == 0x5b) return KB_RBRACKET;
+		if (btn_block[2] == 0x5d) return KB_BACKSLASH;
+
+		if (btn_block[2] == 0x58) return KB_CAPS;
+		if (btn_block[2] == 0x1c) return KB_A;
+		if (btn_block[2] == 0x1b) return KB_S;
+		if (btn_block[2] == 0x23) return KB_D;
+		if (btn_block[2] == 0x2b) return KB_F;
+		if (btn_block[2] == 0x34) return KB_G;
+		if (btn_block[2] == 0x33) return KB_H;
+		if (btn_block[2] == 0x3b) return KB_J;
+		if (btn_block[2] == 0x42) return KB_K;
+		if (btn_block[2] == 0x4b) return KB_L;
+		if (btn_block[2] == 0x4c) return KB_SEMI;
+		if (btn_block[2] == 0x52) return KB_QUOTE;
+		if (btn_block[2] == 0x5a) return KB_RET;
+
+		if (btn_block[2] == 0x88) return KB_LSHIFT;
+		if (btn_block[2] == 0x1a) return KB_Z;
+		if (btn_block[2] == 0x22) return KB_X;
+		if (btn_block[2] == 0x21) return KB_C;
+		if (btn_block[2] == 0x2a) return KB_V;
+		if (btn_block[2] == 0x32) return KB_B;
+		if (btn_block[2] == 0x31) return KB_N;
+		if (btn_block[2] == 0x3a) return KB_M;
+		if (btn_block[2] == 0x41) return KB_COMA;
+		if (btn_block[2] == 0x49) return KB_PERIOD;
+		if (btn_block[2] == 0x89) return KB_RSHIFT;
+
+		if (btn_block[2] == 0x8c) return KB_LCTL;
+		if (btn_block[2] == 0x82) return KB_META;
+		if (btn_block[2] == 0xba) return KB_LALT;
+		if (btn_block[2] == 0x29) return KB_SPACE;
+		if (btn_block[2] == 0x8b) return KB_RALT;
+		if (btn_block[2] == 0x84) return KB_MENU;
+		if (btn_block[2] == 0x8d) return KB_RCTL;
+
+		if (btn_block[2] == 0xc3) return KB_PRNTSCN;
+		if (btn_block[2] == 0x7e) return KB_SCRLCK;
+		if (btn_block[2] == 0x91) return KB_PAUSE;
+		if (btn_block[2] == 0xc2) return KB_INS;
+		if (btn_block[2] == 0x94) return KB_HOME;
+		if (btn_block[2] == 0x96) return KB_PGUP;
+		if (btn_block[2] == 0xc0) return KB_DEL;
+		if (btn_block[2] == 0x95) return KB_END;
+		if (btn_block[2] == 0x97) return KB_PGDWN;
+
+		if (btn_block[2] == 0x99) return KB_UP_ARROW;
+		if (btn_block[2] == 0x98) return KB_DOWN_ARROW;
+		if (btn_block[2] == 0x91) return KB_LEFT_ARROW;
+		if (btn_block[2] == 0x9b) return KB_RIGHT_ARROW;
+
+		if (btn_block[2] == 0x77) return NUMPAD_LCK;
+		if (btn_block[2] == 0x90) return NUMPAD_FWDSLASH;
+		if (btn_block[2] == 0x7c) return NUMPAD_STAR;
+		if (btn_block[2] == 0x7b) return NUMPAD_HYPHEN;
+		if (btn_block[2] == 0x70) return NUMPAD_0;
+		if (btn_block[2] == 0x69) return NUMPAD_1;
+		if (btn_block[2] == 0x72) return NUMPAD_2;
+		if (btn_block[2] == 0x7a) return NUMPAD_3;
+		if (btn_block[2] == 0x6b) return NUMPAD_4;
+		if (btn_block[2] == 0x73) return NUMPAD_5;
+		if (btn_block[2] == 0x74) return NUMPAD_6;
+		if (btn_block[2] == 0x6c) return NUMPAD_7;
+		if (btn_block[2] == 0x75) return NUMPAD_8;
+		if (btn_block[2] == 0x7d) return NUMPAD_9;
+		if (btn_block[2] == 0x79) return NUMPAD_PLUS;
+		if (btn_block[2] == 0x81) return NUMPAD_ENTER;
+		if (btn_block[2] == 0x71) return NUMPAD_PERIOD;
+	}
+
+	if (btn_block[0] == 0x03) {
+		if (btn_block[4] == 0x01) return RAT_LCLICK;
+		if (btn_block[4] == 0x02) return RAT_RCLICK;
+		if (btn_block[4] == 0x03) return RAT_MCLICK;
+		if (btn_block[4] == 0x04) return RAT_WHEEL_UP;
+		if (btn_block[4] == 0x05) return RAT_WHEEL_DOWN;
+	}
+
+	if (btn_block[0] == 0x05) {
+		if (btn_block[3] == 0x16) return MEDIA_SCREENSHOT;
+		if (btn_block[3] == 0x19) return MEDIA_SHOW_KEYBOARD;
+		if (btn_block[3] == 0x1c) return MEDIA_SHOW_DESKTOP;
+		if (btn_block[3] == 0x1e) return MEDIA_START_RECORDING;
+		if (btn_block[3] == 0x01) return MEDIA_MIC_OFF;
+		if (btn_block[3] == 0x02) return MEDIA_VOL_DOWN;
+		if (btn_block[3] == 0x03) return MEDIA_VOL_UP;
+	}
+
+	return "";
+}
+
+/* ASUS ROG Ally device specific attributes */
+
+/* This should be called before any attempts to set device functions */
+static int __gamepad_check_ready(struct hid_device *hdev)
+{
+	u8 *hidbuf;
+	int ret;
+
+	hidbuf = kzalloc(FEATURE_ROG_ALLY_REPORT_SIZE, GFP_KERNEL);
+	if (!hidbuf)
+		return -ENOMEM;
+
+	hidbuf[0] = FEATURE_KBD_REPORT_ID;
+	hidbuf[1] = 0xD1;
+	hidbuf[2] = ally_xpad_cmd_check_ready;
+	hidbuf[3] = 01;
+	ret = asus_kbd_set_report(hdev, hidbuf, FEATURE_ROG_ALLY_REPORT_SIZE);
+	if (ret < 0)
+		goto report_fail;
+
+	hidbuf[0] = hidbuf[1] = hidbuf[2] = hidbuf[3] = 0;
+	ret = asus_kbd_get_report(hdev, hidbuf, FEATURE_ROG_ALLY_REPORT_SIZE);
+	if (ret < 0)
+		goto report_fail;
+
+	ret = hidbuf[2] == ally_xpad_cmd_check_ready;
+	if (!ret) {
+		hid_warn(hdev, "ROG Ally not ready\n");
+		ret = -ENOMSG;
+	}
+
+	kfree(hidbuf);
+	return ret;
+
+report_fail:
+	hid_dbg(hdev, "ROG Ally check failed get report: %d\n", ret);
+	kfree(hidbuf);
+	return ret;
+}
+
+/********** BUTTON REMAPPING *********************************************************************/
+static void __btn_pair_to_pkt(struct device *raw_dev, enum btn_pair pair, u8 *out, int out_len)
+{
+	struct asus_rog_ally *rog_ally = __rog_ally_data(raw_dev);
+
+	out[0] = FEATURE_KBD_REPORT_ID;
+	out[1] = 0xD1;
+	out[2] = 0x02;
+	out[3] = pair;
+	out[4] = 0x2c; //length
+	memcpy(&out[5], &rog_ally->key_mapping[rog_ally->mode - 1][pair - 1], MAPPING_BLOCK_LEN);
+}
+
+/* Store the button setting in driver data. Does not apply to device until __gamepad_set_mapping */
+static int __gamepad_mapping_store(struct device *raw_dev, const char *buf, enum btn_pair pair, int side,
+				   bool secondary)
+{
+	struct asus_rog_ally *rog_ally = __rog_ally_data(raw_dev);
+	u8 *key_code;
+	int offs;
+
+	offs = side ? MAPPING_BLOCK_LEN / 2 : 0;
+	offs = secondary ? offs + BTN_CODE_LEN : offs;
+	key_code = rog_ally->key_mapping[rog_ally->mode - 1][pair - 1] + offs;
+
+	return __string_to_key_code(buf, key_code, BTN_CODE_LEN);
+}
+
+/* Apply the mapping pair to the device */
+static int __gamepad_set_mapping(struct device *raw_dev, enum btn_pair pair)
+{
+	struct hid_device *hdev = to_hid_device(raw_dev);
+	u8 *hidbuf;
+	int ret;
+
+	ret = __gamepad_check_ready(hdev);
+	if (ret < 0)
+		return ret;
+
+	hidbuf = kzalloc(FEATURE_ROG_ALLY_REPORT_SIZE, GFP_KERNEL);
+	if (!hidbuf)
+		return -ENOMEM;
+
+	__btn_pair_to_pkt(raw_dev, pair, hidbuf, FEATURE_ROG_ALLY_REPORT_SIZE);
+	ret = asus_kbd_set_report(hdev, hidbuf, FEATURE_ROG_ALLY_REPORT_SIZE);
+	kfree(hidbuf);
+
+	return ret;
+}
+
+static int __gamepad_set_mapping_all(struct device *raw_dev)
+{
+	struct hid_device *hdev = to_hid_device(raw_dev);
+	int ret;
+
+	ret = __gamepad_set_mapping(&hdev->dev, btn_pair_dpad_u_d);
+	if (ret < 0)
+		return ret;
+	ret = __gamepad_set_mapping(&hdev->dev, btn_pair_dpad_l_r);
+	if (ret < 0)
+		return ret;
+	ret = __gamepad_set_mapping(&hdev->dev, btn_pair_ls_rs);
+	if (ret < 0)
+		return ret;
+	ret = __gamepad_set_mapping(&hdev->dev, btn_pair_lb_rb);
+	if (ret < 0)
+		return ret;
+	ret = __gamepad_set_mapping(&hdev->dev, btn_pair_a_b);
+	if (ret < 0)
+		return ret;
+	ret = __gamepad_set_mapping(&hdev->dev, btn_pair_x_y);
+	if (ret < 0)
+		return ret;
+	ret = __gamepad_set_mapping(&hdev->dev, btn_pair_view_menu);
+	if (ret < 0)
+		return ret;
+	ret = __gamepad_set_mapping(&hdev->dev, btn_pair_m1_m2);
+	if (ret < 0)
+		return ret;
+	return __gamepad_set_mapping(&hdev->dev, btn_pair_lt_rt);
+}
+
+static ssize_t btn_mapping_apply_store(struct device *raw_dev, struct device_attribute *attr,
+				       const char *buf, size_t count)
+{
+	int ret = __gamepad_set_mapping_all(raw_dev);
+	if (ret < 0)
+		return ret;
+	return count;
+}
+ALLY_DEVICE_ATTR_WO(btn_mapping_apply, apply);
+
+/* button map attributes, regular and macro*/
+#define ALLY_BTN_SHOW(_fname, _pair, _side, _secondary) \
+static ssize_t _fname##_show(struct device *raw_dev, struct device_attribute *attr, char *buf) { \
+	return sysfs_emit(buf, "%s\n", __btn_map_to_string(raw_dev, _pair, _side, _secondary)); \
+}
+
+#define ALLY_BTN_STORE(_fname, _pair, _side, _secondary) \
+static ssize_t _fname##_store(struct device *raw_dev, struct device_attribute *attr, \
+				   const char *buf, size_t count) { \
+	int ret = __gamepad_mapping_store(raw_dev, buf, _pair, _side, _secondary); \
+	if (ret < 0) return ret; \
+	return count; \
+}
+
+#define ALLY_BTN_MAPPING(_fname, _sysname, _pair, _side) \
+	ALLY_BTN_SHOW(_fname, _pair, _side, false); \
+	ALLY_BTN_STORE(_fname, _pair, _side, false); \
+	ALLY_BTN_SHOW(_fname##_macro, _pair, _side, true); \
+	ALLY_BTN_STORE(_fname##_macro, _pair, _side, true); \
+	ALLY_DEVICE_ATTR_RW(_fname, _sysname); \
+	ALLY_DEVICE_ATTR_RW(_fname##_macro, _sysname##_macro);
+
+ALLY_BTN_MAPPING(btn_mapping_m2, M2, btn_pair_m1_m2, btn_pair_side_left);
+ALLY_BTN_MAPPING(btn_mapping_m1, M1, btn_pair_m1_m2, btn_pair_side_right);
+ALLY_BTN_MAPPING(btn_mapping_a, A, btn_pair_a_b, btn_pair_side_left);
+ALLY_BTN_MAPPING(btn_mapping_b, B, btn_pair_a_b, btn_pair_side_right);
+ALLY_BTN_MAPPING(btn_mapping_x, X, btn_pair_x_y, btn_pair_side_left);
+ALLY_BTN_MAPPING(btn_mapping_y, Y, btn_pair_x_y, btn_pair_side_right);
+ALLY_BTN_MAPPING(btn_mapping_lb, LB, btn_pair_lb_rb, btn_pair_side_left);
+ALLY_BTN_MAPPING(btn_mapping_rb, RB, btn_pair_lb_rb, btn_pair_side_right);
+ALLY_BTN_MAPPING(btn_mapping_ls, LS, btn_pair_ls_rs, btn_pair_side_left);
+ALLY_BTN_MAPPING(btn_mapping_rs, RS, btn_pair_ls_rs, btn_pair_side_right);
+ALLY_BTN_MAPPING(btn_mapping_lt, LT, btn_pair_lt_rt, btn_pair_side_left);
+ALLY_BTN_MAPPING(btn_mapping_rt, RT, btn_pair_lt_rt, btn_pair_side_right);
+ALLY_BTN_MAPPING(btn_mapping_dpad_u, dpad_U, btn_pair_dpad_u_d, btn_pair_side_left);
+ALLY_BTN_MAPPING(btn_mapping_dpad_d, dpad_D, btn_pair_dpad_u_d, btn_pair_side_right);
+ALLY_BTN_MAPPING(btn_mapping_dpad_l, dpad_L, btn_pair_dpad_l_r, btn_pair_side_left);
+ALLY_BTN_MAPPING(btn_mapping_dpad_r, dpad_R, btn_pair_dpad_l_r, btn_pair_side_right);
+ALLY_BTN_MAPPING(btn_mapping_view, view, btn_pair_view_menu, btn_pair_side_left);
+ALLY_BTN_MAPPING(btn_mapping_menu, menu, btn_pair_view_menu, btn_pair_side_right);
+
+static void __gamepad_mapping_xpad_default(struct asus_rog_ally *rog_ally)
+{
+	u8 map1[MAPPING_BLOCK_LEN] = {0x01,0x09,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x05,0x00,0x00,0x19,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x0a,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x03,0x8c,0x88,0x76,0x00,0x00};
+	u8 map2[MAPPING_BLOCK_LEN] = {0x01,0x0b,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x02,0x82,0x23,0x00,0x00,0x00,0x01,0x0c,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x02,0x82,0x0d,0x00,0x00,0x00};
+	u8 map3[MAPPING_BLOCK_LEN] = {0x01,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
+	u8 map4[MAPPING_BLOCK_LEN] = {0x01,0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
+	u8 map5[MAPPING_BLOCK_LEN] = {0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x05,0x00,0x00,0x16,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x02,0x82,0x31,0x00,0x00,0x00};
+	u8 map6[MAPPING_BLOCK_LEN] = {0x01,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x02,0x82,0x4d,0x00,0x00,0x00,0x01,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x05,0x00,0x00,0x1e,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
+	u8 map7[MAPPING_BLOCK_LEN] = {0x01,0x11,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x12,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
+	u8 map8[MAPPING_BLOCK_LEN] = {0x02,0x00,0x8e,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x8e,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x8f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x8f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
+	u8 map9[MAPPING_BLOCK_LEN] = {0x01,0x0d,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x0e,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
+	memcpy(&rog_ally->key_mapping[0][0], &map1, MAPPING_BLOCK_LEN);
+	memcpy(&rog_ally->key_mapping[0][1], &map2, MAPPING_BLOCK_LEN);
+	memcpy(&rog_ally->key_mapping[0][2], &map3, MAPPING_BLOCK_LEN);
+	memcpy(&rog_ally->key_mapping[0][3], &map4, MAPPING_BLOCK_LEN);
+	memcpy(&rog_ally->key_mapping[0][4], &map5, MAPPING_BLOCK_LEN);
+	memcpy(&rog_ally->key_mapping[0][5], &map6, MAPPING_BLOCK_LEN);
+	memcpy(&rog_ally->key_mapping[0][6], &map7, MAPPING_BLOCK_LEN);
+	memcpy(&rog_ally->key_mapping[0][7], &map8, MAPPING_BLOCK_LEN);
+	memcpy(&rog_ally->key_mapping[0][8], &map9, MAPPING_BLOCK_LEN);
+}
+
+static void __gamepad_mapping_wasd_default(struct asus_rog_ally *rog_ally)
+{
+	u8 map1[MAPPING_BLOCK_LEN] = {0x02,0x00,0x98,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x05,0x00,0x00,0x19,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x99,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x03,0x8c,0x88,0x76,0x00,0x00};
+	u8 map2[MAPPING_BLOCK_LEN] = {0x02,0x00,0x9a,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x02,0x82,0x23,0x00,0x00,0x00,0x02,0x00,0x9b,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x02,0x82,0x0d,0x00,0x00,0x00};
+	u8 map3[MAPPING_BLOCK_LEN] = {0x02,0x00,0x88,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
+	u8 map4[MAPPING_BLOCK_LEN] = {0x02,0x00,0x0d,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
+	u8 map5[MAPPING_BLOCK_LEN] = {0x02,0x00,0x5a,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x05,0x00,0x00,0x16,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x76,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x02,0x82,0x31,0x00,0x00,0x00};
+	u8 map6[MAPPING_BLOCK_LEN] = {0x02,0x00,0x97,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x02,0x82,0x4d,0x00,0x00,0x00,0x02,0x00,0x96,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x05,0x00,0x00,0x1e,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
+	u8 map7[MAPPING_BLOCK_LEN] = {0x01,0x11,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x12,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
+	u8 map8[MAPPING_BLOCK_LEN] = {0x02,0x00,0x8e,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x8e,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x8f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x8f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
+	u8 map9[MAPPING_BLOCK_LEN] = {0x04,0x00,0x00,0x00,0x00,0x02,0x88,0x0d,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
+	memcpy(&rog_ally->key_mapping[1][0], &map1, MAPPING_BLOCK_LEN);
+	memcpy(&rog_ally->key_mapping[1][1], &map2, MAPPING_BLOCK_LEN);
+	memcpy(&rog_ally->key_mapping[1][2], &map3, MAPPING_BLOCK_LEN);
+	memcpy(&rog_ally->key_mapping[1][3], &map4, MAPPING_BLOCK_LEN);
+	memcpy(&rog_ally->key_mapping[1][4], &map5, MAPPING_BLOCK_LEN);
+	memcpy(&rog_ally->key_mapping[1][5], &map6, MAPPING_BLOCK_LEN);
+	memcpy(&rog_ally->key_mapping[1][6], &map7, MAPPING_BLOCK_LEN);
+	memcpy(&rog_ally->key_mapping[1][7], &map8, MAPPING_BLOCK_LEN);
+	memcpy(&rog_ally->key_mapping[1][8], &map9, MAPPING_BLOCK_LEN);
+}
+
+static ssize_t btn_mapping_reset_store(struct device *raw_dev, struct device_attribute *attr,
+				  const char *buf, size_t count)
+{
+	struct asus_rog_ally *rog_ally = __rog_ally_data(raw_dev);
+	switch (rog_ally->mode)
+	{
+	case ally_xpad_mode_game:
+		__gamepad_mapping_xpad_default(rog_ally);
+		break;
+	case ally_xpad_mode_wasd:
+		__gamepad_mapping_wasd_default(rog_ally);
+		break;
+	default:
+		__gamepad_mapping_xpad_default(rog_ally);
+		break;
+	}
+
+	return count;
+}
+
+ALLY_DEVICE_ATTR_WO(btn_mapping_reset, reset);
+
+static struct attribute *gamepad_button_mapping_attrs[] = { &dev_attr_btn_mapping_apply.attr,
+							    &dev_attr_btn_mapping_reset.attr,
+							    &dev_attr_btn_mapping_m2.attr,
+							    &dev_attr_btn_mapping_m2_macro.attr,
+							    &dev_attr_btn_mapping_m1.attr,
+							    &dev_attr_btn_mapping_m1_macro.attr,
+							    &dev_attr_btn_mapping_a.attr,
+							    &dev_attr_btn_mapping_a_macro.attr,
+							    &dev_attr_btn_mapping_b.attr,
+							    &dev_attr_btn_mapping_b_macro.attr,
+							    &dev_attr_btn_mapping_x.attr,
+							    &dev_attr_btn_mapping_x_macro.attr,
+							    &dev_attr_btn_mapping_y.attr,
+							    &dev_attr_btn_mapping_y_macro.attr,
+							    &dev_attr_btn_mapping_lb.attr,
+							    &dev_attr_btn_mapping_lb_macro.attr,
+							    &dev_attr_btn_mapping_rb.attr,
+							    &dev_attr_btn_mapping_rb_macro.attr,
+							    &dev_attr_btn_mapping_ls.attr,
+							    &dev_attr_btn_mapping_ls_macro.attr,
+							    &dev_attr_btn_mapping_rs.attr,
+							    &dev_attr_btn_mapping_rs_macro.attr,
+							    &dev_attr_btn_mapping_lt.attr,
+							    &dev_attr_btn_mapping_lt_macro.attr,
+							    &dev_attr_btn_mapping_rt.attr,
+							    &dev_attr_btn_mapping_rt_macro.attr,
+							    &dev_attr_btn_mapping_dpad_u.attr,
+							    &dev_attr_btn_mapping_dpad_u_macro.attr,
+							    &dev_attr_btn_mapping_dpad_d.attr,
+							    &dev_attr_btn_mapping_dpad_d_macro.attr,
+							    &dev_attr_btn_mapping_dpad_l.attr,
+							    &dev_attr_btn_mapping_dpad_l_macro.attr,
+							    &dev_attr_btn_mapping_dpad_r.attr,
+							    &dev_attr_btn_mapping_dpad_r_macro.attr,
+							    &dev_attr_btn_mapping_view.attr,
+							    &dev_attr_btn_mapping_view_macro.attr,
+							    &dev_attr_btn_mapping_menu.attr,
+							    &dev_attr_btn_mapping_menu_macro.attr,
+							    NULL };
+
+static const struct attribute_group ally_controller_button_mapping_attr_group = {
+	.name = "button_mapping",
+	.attrs = gamepad_button_mapping_attrs,
+};
+
+/********** GAMEPAD MODE *************************************************************************/
+// TODO: general purpose request function which checks the device is ready before setting
+/* The gamepad mode also needs to be set on boot/mod-load and shutdown */
+static ssize_t __gamepad_set_mode(struct device *raw_dev, int val)
+{
+	struct hid_device *hdev = to_hid_device(raw_dev);
+	u8 *hidbuf;
+	int ret;
+
+	ret = __gamepad_check_ready(hdev);
+	if (ret < 0)
+		return ret;
+
+	hidbuf = kzalloc(FEATURE_ROG_ALLY_REPORT_SIZE, GFP_KERNEL);
+	if (!hidbuf)
+		return -ENOMEM;
+
+	hidbuf[0] = FEATURE_KBD_REPORT_ID;
+	hidbuf[1] = 0xD1;
+	hidbuf[2] = ally_xpad_cmd_set_mode;
+	hidbuf[3] = 0x01;
+	hidbuf[4] = val;
+
+	ret = __gamepad_check_ready(hdev);
+	if (ret < 0)
+		goto report_fail;
+
+	ret = asus_kbd_set_report(hdev, hidbuf, FEATURE_ROG_ALLY_REPORT_SIZE);
+	if (ret < 0)
+		goto report_fail;
+
+report_fail:
+	kfree(hidbuf);
+	return ret;
+}
+
+static ssize_t gamepad_mode_show(struct device *raw_dev, struct device_attribute *attr, char *buf)
+{
+	struct asus_rog_ally *rog_ally = __rog_ally_data(raw_dev);
+	return sysfs_emit(buf, "%d\n", rog_ally->mode);
+}
+
+static ssize_t gamepad_mode_store(struct device *raw_dev, struct device_attribute *attr,
+				  const char *buf, size_t count)
+{
+	struct asus_rog_ally *rog_ally = __rog_ally_data(raw_dev);
+	int ret, val;
+
+	ret = kstrtoint(buf, 0, &val);
+	if (ret)
+		return ret;
+
+	if (val < ally_xpad_mode_game || val > ally_xpad_mode_mouse)
+		return -EINVAL;
+
+	rog_ally->mode = val;
+
+	ret = __gamepad_set_mode(raw_dev, val);
+	if (ret < 0)
+		return ret;
+
+	return count;
+}
+
+DEVICE_ATTR_RW(gamepad_mode);
+
+static struct attribute *gamepad_device_attrs[] = { &dev_attr_gamepad_mode.attr, NULL };
+
+static const struct attribute_group ally_controller_attr_group = {
+	.attrs = gamepad_device_attrs,
+};
+
+/********** ANALOGUE DEADZONES ********************************************************************/
+static ssize_t __gamepad_set_deadzones(struct device *raw_dev, enum ally_xpad_axis axis,
+				       const char *buf)
+{
+	struct asus_rog_ally *rog_ally = __rog_ally_data(raw_dev);
+	struct hid_device *hdev = to_hid_device(raw_dev);
+	int ret, cmd, side, is_tr;
+	u32 inner, outer;
+	u8 *hidbuf;
+
+	if (sscanf(buf, "%d %d", &inner, &outer) != 2)
+		return -EINVAL;
+
+	if (inner > 64 || outer > 64 || inner > outer)
+		return -EINVAL;
+
+	is_tr = axis > ally_xpad_axis_xy_right;
+	side = axis == ally_xpad_axis_xy_right || axis == ally_xpad_axis_z_right ? 2 : 0;
+	cmd = is_tr ? ally_xpad_cmd_set_js_dz : ally_xpad_cmd_set_tr_dz;
+
+	rog_ally->deadzones[is_tr][side] = inner;
+	rog_ally->deadzones[is_tr][side + 1] = outer;
+
+	ret = __gamepad_check_ready(hdev);
+	if (ret < 0)
+		return ret;
+
+	hidbuf = kzalloc(FEATURE_ROG_ALLY_REPORT_SIZE, GFP_KERNEL);
+	if (!hidbuf)
+		return -ENOMEM;
+
+	hidbuf[0] = FEATURE_KBD_REPORT_ID;
+	hidbuf[1] = 0xD1;
+	hidbuf[2] = cmd;
+	hidbuf[3] = 0x04; // length
+	hidbuf[4] = rog_ally->deadzones[is_tr][0];
+	hidbuf[5] = rog_ally->deadzones[is_tr][1];
+	hidbuf[6] = rog_ally->deadzones[is_tr][2];
+	hidbuf[7] = rog_ally->deadzones[is_tr][3];
+
+	ret = asus_kbd_set_report(hdev, hidbuf, FEATURE_ROG_ALLY_REPORT_SIZE);
+	kfree(hidbuf);
+	return ret;
+}
+
+static ssize_t axis_xyz_deadzone_index_show(struct device *raw_dev, struct device_attribute *attr,
+					    char *buf)
+{
+	return sysfs_emit(buf, "inner outer\n");
+}
+
+static ssize_t axis_xy_left_deadzone_show(struct device *raw_dev, struct device_attribute *attr,
+					  char *buf)
+{
+	struct asus_rog_ally *rog_ally = __rog_ally_data(raw_dev);
+	return sysfs_emit(buf, "%d %d\n", rog_ally->deadzones[0][0], rog_ally->deadzones[0][1]);
+}
+
+static ssize_t axis_xy_left_deadzone_store(struct device *raw_dev, struct device_attribute *attr,
+					   const char *buf, size_t count)
+{
+	int ret = __gamepad_set_deadzones(raw_dev, ally_xpad_axis_xy_left, buf);
+	if (ret < 0)
+		return ret;
+	return count;
+}
+
+static ssize_t axis_xy_right_deadzone_show(struct device *raw_dev, struct device_attribute *attr,
+					   char *buf)
+{
+	struct asus_rog_ally *rog_ally = __rog_ally_data(raw_dev);
+	return sysfs_emit(buf, "%d %d\n", rog_ally->deadzones[0][2], rog_ally->deadzones[0][3]);
+}
+
+static ssize_t axis_xy_right_deadzone_store(struct device *raw_dev, struct device_attribute *attr,
+					    const char *buf, size_t count)
+{
+	int ret = __gamepad_set_deadzones(raw_dev, ally_xpad_axis_xy_right, buf);
+	if (ret < 0)
+		return ret;
+	return count;
+}
+
+static ssize_t axis_z_left_deadzone_show(struct device *raw_dev, struct device_attribute *attr,
+					 char *buf)
+{
+	struct asus_rog_ally *rog_ally = __rog_ally_data(raw_dev);
+	return sysfs_emit(buf, "%d %d\n", rog_ally->deadzones[1][0], rog_ally->deadzones[1][1]);
+}
+
+static ssize_t axis_z_left_deadzone_store(struct device *raw_dev, struct device_attribute *attr,
+					  const char *buf, size_t count)
+{
+	int ret = __gamepad_set_deadzones(raw_dev, ally_xpad_axis_z_left, buf);
+	if (ret < 0)
+		return ret;
+	return count;
+}
+
+static ssize_t axis_z_right_deadzone_show(struct device *raw_dev, struct device_attribute *attr,
+					  char *buf)
+{
+	struct asus_rog_ally *rog_ally = __rog_ally_data(raw_dev);
+	return sysfs_emit(buf, "%d %d\n", rog_ally->deadzones[1][2], rog_ally->deadzones[1][3]);
+}
+
+static ssize_t axis_z_right_deadzone_store(struct device *raw_dev, struct device_attribute *attr,
+					   const char *buf, size_t count)
+{
+	int ret = __gamepad_set_deadzones(raw_dev, ally_xpad_axis_z_right, buf);
+	if (ret < 0)
+		return ret;
+	return count;
+}
+
+ALLY_DEVICE_ATTR_RO(axis_xyz_deadzone_index, deadzone_index);
+ALLY_DEVICE_ATTR_RW(axis_xy_left_deadzone, deadzone);
+ALLY_DEVICE_ATTR_RW(axis_xy_right_deadzone, deadzone);
+ALLY_DEVICE_ATTR_RW(axis_z_left_deadzone, deadzone);
+ALLY_DEVICE_ATTR_RW(axis_z_right_deadzone, deadzone);
+
+static struct attribute *gamepad_axis_xy_left_attrs[] = { &dev_attr_axis_xy_left_deadzone.attr,
+							  &dev_attr_axis_xyz_deadzone_index.attr,
+							  NULL };
+static const struct attribute_group ally_controller_axis_xy_left_attr_group = {
+	.name = "axis_xy_left",
+	.attrs = gamepad_axis_xy_left_attrs,
+};
+
+static struct attribute *gamepad_axis_xy_right_attrs[] = { &dev_attr_axis_xy_right_deadzone.attr,
+							   &dev_attr_axis_xyz_deadzone_index.attr,
+							   NULL };
+static const struct attribute_group ally_controller_axis_xy_right_attr_group = {
+	.name = "axis_xy_right",
+	.attrs = gamepad_axis_xy_right_attrs,
+};
+
+static struct attribute *gamepad_axis_z_left_attrs[] = { &dev_attr_axis_z_left_deadzone.attr,
+							 &dev_attr_axis_xyz_deadzone_index.attr,
+							 NULL };
+static const struct attribute_group ally_controller_axis_z_left_attr_group = {
+	.name = "axis_z_left",
+	.attrs = gamepad_axis_z_left_attrs,
+};
+
+static struct attribute *gamepad_axis_z_right_attrs[] = { &dev_attr_axis_z_right_deadzone.attr,
+							  &dev_attr_axis_xyz_deadzone_index.attr,
+							  NULL };
+
+static const struct attribute_group ally_controller_axis_z_right_attr_group = {
+	.name = "axis_z_right",
+	.attrs = gamepad_axis_z_right_attrs,
+};
+
+static const struct attribute_group *gamepad_device_attr_groups[] = {
+	&ally_controller_attr_group,
+	&ally_controller_axis_xy_left_attr_group,
+	&ally_controller_axis_xy_right_attr_group,
+	&ally_controller_axis_z_left_attr_group,
+	&ally_controller_axis_z_right_attr_group,
+	&ally_controller_button_mapping_attr_group,
+	NULL
+};
+
+static int asus_rog_ally_probe(struct hid_device *hdev, const struct rog_ops *ops)
+{
+	struct asus_drvdata *drvdata = hid_get_drvdata(hdev);
+	int ret;
+
+	/* all ROG devices have this HID interface but we will focus on Ally for now */
+	if (drvdata->quirks & QUIRK_ROG_NKEY_KEYBOARD && hid_is_usb(hdev)) {
+		struct usb_interface *intf = to_usb_interface(hdev->dev.parent);
+
+		if (intf->altsetting->desc.bInterfaceNumber == 0) {
+			hid_info(hdev, "Setting up ROG USB interface\n");
+			/* initialise and set up USB, common to ROG */
+			// TODO:
+
+			/* initialise the Ally data */
+			if (drvdata->quirks & QUIRK_ROG_ALLY_XPAD) {
+				hid_info(hdev, "Setting up ROG Ally interface\n");
+
+				drvdata->rog_ally_data = devm_kzalloc(
+					&hdev->dev, sizeof(*drvdata->rog_ally_data), GFP_KERNEL);
+				if (!drvdata->rog_ally_data) {
+					hid_err(hdev, "Can't alloc Asus ROG USB interface\n");
+					ret = -ENOMEM;
+					goto err_stop_hw;
+				}
+				drvdata->rog_ally_data->mode = ally_xpad_mode_game;
+				drvdata->rog_ally_data->deadzones[0][1] = 64;
+				drvdata->rog_ally_data->deadzones[0][3] = 64;
+				drvdata->rog_ally_data->deadzones[1][1] = 64;
+				drvdata->rog_ally_data->deadzones[1][3] = 64;
+
+				ret = __gamepad_set_mode(&hdev->dev, ally_xpad_mode_game);
+				if (ret < 0)
+					return ret;
+				__gamepad_mapping_xpad_default(drvdata->rog_ally_data);
+				// these calls will never error so ignore the return
+				__gamepad_mapping_store(&hdev->dev, "kb_f14", btn_pair_m1_m2,
+							      btn_pair_side_left, false); // M2
+				__gamepad_mapping_store(&hdev->dev, "kb_f15", btn_pair_m1_m2,
+							      btn_pair_side_right, false); // M1
+				ret = __gamepad_set_mapping(&hdev->dev, btn_pair_m1_m2);
+				if (ret < 0)
+					return ret;
+			}
+
+			if (sysfs_create_groups(&hdev->dev.kobj, gamepad_device_attr_groups))
+				goto err_stop_hw;
+		}
+	}
+
+	return 0;
+err_stop_hw:
+	hid_hw_stop(hdev);
+	return ret;
+}
+
+void asus_rog_ally_remove(struct hid_device *hdev, const struct rog_ops *ops)
+{
+	struct asus_drvdata *drvdata = hid_get_drvdata(hdev);
+	if (drvdata->rog_ally_data) {
+		__gamepad_set_mode(&hdev->dev, ally_xpad_mode_mouse);
+		sysfs_remove_groups(&hdev->dev.kobj, gamepad_device_attr_groups);
+	}
+}
+
+const struct rog_ops rog_ally = {
+	.probe = asus_rog_ally_probe,
+	.remove = asus_rog_ally_remove,
+};
diff --git a/drivers/hid/hid-asus.h b/drivers/hid/hid-asus.h
new file mode 100644
index 000000000000..e7d7041b56fb
--- /dev/null
+++ b/drivers/hid/hid-asus.h
@@ -0,0 +1,51 @@
+#include <linux/hid.h>
+#include <linux/types.h>
+
+#define FEATURE_KBD_REPORT_ID		0x5a
+#define FEATURE_KBD_REPORT_SIZE		16
+#define FEATURE_KBD_LED_REPORT_ID1	0x5d
+#define FEATURE_KBD_LED_REPORT_ID2	0x5e
+#define FEATURE_ROG_ALLY_REPORT_SIZE	64
+
+#define QUIRK_FIX_NOTEBOOK_REPORT	BIT(0)
+#define QUIRK_NO_INIT_REPORTS		BIT(1)
+#define QUIRK_SKIP_INPUT_MAPPING	BIT(2)
+#define QUIRK_IS_MULTITOUCH		BIT(3)
+#define QUIRK_NO_CONSUMER_USAGES	BIT(4)
+#define QUIRK_USE_KBD_BACKLIGHT		BIT(5)
+#define QUIRK_T100_KEYBOARD		BIT(6)
+#define QUIRK_T100CHI			BIT(7)
+#define QUIRK_G752_KEYBOARD		BIT(8)
+#define QUIRK_T90CHI			BIT(9)
+#define QUIRK_MEDION_E1239T		BIT(10)
+#define QUIRK_ROG_NKEY_KEYBOARD		BIT(11)
+#define QUIRK_ROG_CLAYMORE_II_KEYBOARD	BIT(12)
+#define QUIRK_ROG_ALLY_XPAD		BIT(13)
+
+struct asus_drvdata {
+	unsigned long quirks;
+	struct hid_device *hdev;
+	struct input_dev *input;
+	struct input_dev *tp_kbd_input;
+	struct asus_kbd_leds *kbd_backlight;
+	const struct asus_touchpad_info *tp;
+	bool enable_backlight;
+	struct power_supply *battery;
+	struct power_supply_desc battery_desc;
+	int battery_capacity;
+	int battery_stat;
+	bool battery_in_query;
+	unsigned long battery_next_query;
+	struct asus_rog_ally *rog_ally_data;
+};
+
+extern int asus_kbd_set_report(struct hid_device *hdev, const u8 *buf, size_t buf_size);
+
+extern int asus_kbd_get_report(struct hid_device *hdev, u8 *out_buf, size_t out_buf_size);
+
+struct rog_ops {
+	int (*probe) (struct hid_device *hdev, const struct rog_ops *ops);
+	void (*remove) (struct hid_device *hdev, const struct rog_ops *ops);
+};
+
+extern const struct rog_ops rog_ally;
\ No newline at end of file
-- 
2.41.0

